{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-20T02:01:28.626904+00:00",
  "repo": "tlswg/tls-key-update",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMJPqLM6MOilY",
      "title": "Tiru's Review Comments",
      "url": "https://github.com/tlswg/tls-key-update/issues/1",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1.  I can't parse the below line:\r\n\"Send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys.\"\r\n\r\n2. The fig-key-update sequence diagram does not reflect the use of ExtendedKeyUpdateRequest, ExtendedKeyUpdateResponse and NewKeyUpdate.\r\n\r\n3. If implementations independently initiate the extended key update procedure, and they cross in flight, the result is that each side increments keys by two generations.\r\n\r\ncomment> Another way to handle the race condition is that ExtendedKeyUpdateRequest which has lower lexicographic order will be discarded by the TLS peer. This approach ensures that only one key update is processed, avoiding the need to compute the keys twice and thereby simplifying the process.\r\n\r\nAlternatively, a default policy where the server has a higher precedence and in case of a race condition the ExtendedKeyUpdateRequest  from the client would be discarded. \r\n\r\n4. Once client_/server_application_traffic_secret_N+1 and its associated\r\ntraffic keys have been computed, implementations SHOULD delete\r\nclient_/server_application_traffic_secret_N and its associated\r\ntraffic keys.\r\n\r\ncomment> The client_/server_application_traffic_secret_N and its associated traffic keys can only be deleted after receiving the NewKeyUpdate message. \r\n\r\n5.  I would modify the application_traffic_secret_N+1 as follows:\r\n\r\n sk = HKDF-Extract(Transcript-Hash(KeyUpdateMessages), secret) // secret derived from DH exchange or hybrid key exchange\r\n application_traffic_secret_N+1 =\r\n     Derive-Secret(sk,\"traffic upd 2\",\r\n                     application_traffic_secret_N)\r\n\r\nThe next generation of traffic keys is computed using the HKDF, as defined in [RFC5869], and its two components, HKDF-Extract and     HKDF-Expand, as recommended in Appendix F.1.1 of [I-D.ietf-tls-rfc8446bis]. It would also ensure that client_application_traffic_secret_N+1 and sever_application_traffic_secret_N+1 are different. It also uses application_traffic_secret_N to create a binding security property to the prior key. \r\n\r\n7. The step 4 discussed in \"Extended Key Update Message\" does not look complete to me.\r\n\r\n8. Remove the following line (it does not discuss hybrid key exchange, it only refers to use of ML-KEM):\r\n\"TLS supports the hybrid key exchange based on the extension defined in {{I-D.connolly-tls-mlkem-key-agreement}}\"",
      "createdAt": "2024-06-14T06:27:56Z",
      "updatedAt": "2024-06-15T10:17:48Z",
      "closedAt": "2024-06-15T10:17:48Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOMJPqLM6MRMe8",
      "title": "Handling Key Updates by both Peers",
      "url": "https://github.com/tlswg/tls-key-update/issues/2",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\n> If implementations independently initiate the extended key update procedure, and they cross in flight, the result is that each side increments keys by two generations.\r\n\r\ncomment> Another way to handle the race condition is that ExtendedKeyUpdateRequest which has lower lexicographic order will be discarded by the TLS peer. This approach ensures that only one key update is processed, avoiding the need to compute the keys twice and thereby simplifying the process.\r\n\r\nAlternatively, a default policy where the server has a higher precedence and in case of a race condition the ExtendedKeyUpdateRequest from the client would be discarded.",
      "createdAt": "2024-06-14T12:53:55Z",
      "updatedAt": "2024-07-06T14:17:12Z",
      "closedAt": "2024-07-06T14:17:12Z",
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be in favor with the alternative as it also aligns with the cipher suite negotiation. Here also the server has the last word in the selection.  ",
          "createdAt": "2024-07-04T18:30:02Z",
          "updatedAt": "2024-07-04T18:30:02Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOMJPqLM6MRM7M",
      "title": "Key Derivation",
      "url": "https://github.com/tlswg/tls-key-update/issues/3",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nI would modify the application_traffic_secret_N+1 as follows:\r\n\r\nsk = HKDF-Extract(Transcript-Hash(KeyUpdateMessages), secret) // secret derived from DH exchange or hybrid key exchange\r\napplication_traffic_secret_N+1 =\r\nDerive-Secret(sk,\"traffic upd 2\",\r\napplication_traffic_secret_N)\r\n\r\nThe next generation of traffic keys is computed using the HKDF, as defined in [RFC5869], and its two components, HKDF-Extract and HKDF-Expand, as recommended in Appendix F.1.1 of [I-D.ietf-tls-rfc8446bis]. It would also ensure that client_application_traffic_secret_N+1 and sever_application_traffic_secret_N+1 are different. It also uses application_traffic_secret_N to create a binding security property to the prior key.",
      "createdAt": "2024-06-14T12:54:55Z",
      "updatedAt": "2024-06-15T10:17:58Z",
      "closedAt": "2024-06-15T10:17:58Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOMJPqLM60DFTn",
      "title": "Update to the exchange sequence",
      "url": "https://github.com/tlswg/tls-key-update/issues/19",
      "state": "CLOSED",
      "author": "rifaat-ietf",
      "authorAssociation": "NONE",
      "assignees": [
        "rifaat-ietf"
      ],
      "labels": [],
      "body": "Hi Hannes, \n\nAs per our discussion, I would like to discuss a potential change to the exchange sequence to accommodate a different use case, as follows:\n\nThe exchange has the following steps:\n\n   1.  Initiator sends a ExtendedKeyUpdateRequest message, which\n       contains a key share.  While an extended key update is in\n       progress, the initiator MUST NOT initiate further key updates.\n\n   2.  On receipt of the ExtendedKeyUpdateRequest message, the responder\n       sends the ExtendedKeyUpdateResponse message.  \n       \n       If the responder accepts the request, it sets the status to accepted \n       and includes its own key share. At this point, the responder is able\n       to derive a secret key based on the exchanged key shares, and the application\n       is able to obtain the Exported Keying Material (EKM).\n       \n       If the responder declines the request, it sets the status accordingly \n       and does not include the key share.\n\n       While an extended key update is in progress, the responder MUST\n       NOT initiate further key updates.\n\n\n   3.  On receipt of the ExtendedKeyUpdateResponse message with accepted\n       status, the initiator is able to derive a secret key based on the\n       exchanged key shares, and the application is able to obtain the EKM.\n       \n   4.  At this point, the application is able to use the EKM to derive\n       additional keys and be ready to send them to HW that will use them for\n       encryption/decryption. When the initiator is ready to start using the\n       new keys, the initiator sends a NewKeyUpdate message and MUST update\n       its traffic keys and MUST send all its traffic using the next\n       generation of keys.  \n       \n       The NewKeyUpdate message is intentionally an empty structure that\n       triggers the transition to new keying material.\n\nHappy to discuss this further, if needed.\n",
      "createdAt": "2025-04-25T18:10:59Z",
      "updatedAt": "2025-11-13T10:03:16Z",
      "closedAt": "2025-11-13T10:03:16Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "@rifaat-ietf - The exchange sequence has gone through significant changes, please go through it and let us know if you have any issues. ",
          "createdAt": "2025-10-13T06:57:57Z",
          "updatedAt": "2025-10-13T06:57:57Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "I am closing this issue for now, @rifaat-ietf - please feel free to re-open it if you see any issues with the updated exchange sequence.",
          "createdAt": "2025-11-13T10:03:16Z",
          "updatedAt": "2025-11-13T10:03:16Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOMJPqLM60I7T6",
      "title": "Updating Traffic Secrets",
      "url": "https://github.com/tlswg/tls-key-update/issues/20",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Working on the implementation I was wondering whether it would make sense to use a different key hierarchy. Here is what the TLS RFC specifies for the application traffic secrets, the exporter master secret and the resumption master secrets.\n\n>              |\n>              v\n>    0 -> HKDF-Extract = Master Secret\n>              |\n>              +-----> Derive-Secret(., \"c ap traffic\",\n>              |                     ClientHello...server Finished)\n>              |                     = client_application_traffic_secret_0\n>              |\n>              +-----> Derive-Secret(., \"s ap traffic\",\n>              |                     ClientHello...server Finished)\n>              |                     = server_application_traffic_secret_0\n>              |\n>              +-----> Derive-Secret(., \"exp master\",\n>              |                     ClientHello...server Finished)\n>              |                     = exporter_master_secret\n>              |\n>              +-----> Derive-Secret(., \"res master\",\n>                                    ClientHello...client Finished)\n>                                    = resumption_master_secret\n\nCurrently, draft version -04 uses the current application traffic secret and also computes a new exporter secret based on the following key hierarchy. The resumption_master_secret so far is left untouched.\n\nQuestion: \n1) Should also say something about the resumption master secret update?\n2) Should we recompute the master secret instead?",
      "createdAt": "2025-04-26T19:21:49Z",
      "updatedAt": "2025-10-30T16:31:07Z",
      "closedAt": "2025-10-30T16:31:07Z",
      "comments": [
        {
          "author": "ctz",
          "authorAssociation": "NONE",
          "body": "Can this actually change the exporter or resumption secrets? The whole KeyUpdate arrangement (original or extended) is very fundamentally per-direction, and these secrets are not per-direction. \n\nTo put it another way, how exactly would an application using an exporter reliably export the same secret on the two peers, against a background of all possible in-flight extended key update states?",
          "createdAt": "2025-04-27T09:40:17Z",
          "updatedAt": "2025-04-27T09:40:17Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can this actually change the exporter or resumption secrets? The whole KeyUpdate arrangement (original or extended) is very fundamentally per-direction, and these secrets are not per-direction.\n\nUnlike traditional KeyUpdate, Extended KeyUpdate is fundamentally bidirectional as it performs a fresh key exchange.\n\n> To put it another way, how exactly would an application using an exporter reliably export the same secret on the two peers, against a background of all possible in-flight extended key update states?\n\nApplication would need to be informed that exporter secret has changed.\n\n> Should also say something about the resumption master secret update?\n> Should we recompute the master secret instead?\n\nYes, I believe we should derive new resumption master secret to deliver on post-compromise security promise.\n\n\n",
          "createdAt": "2025-04-29T15:25:45Z",
          "updatedAt": "2025-04-29T15:25:45Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "PR https://github.com/tlswg/tls-key-update/pull/33 contains a proposal for a new key derivation procedure.",
          "createdAt": "2025-07-05T16:40:43Z",
          "updatedAt": "2025-07-05T16:40:43Z"
        },
        {
          "author": "ctz",
          "authorAssociation": "NONE",
          "body": "I think significant work is needed to describe:\n\n\n- How exporters now work, and how/whether peers can no longer actually agree on the same exporter output at all times in the connection's life. This is quite a big change to the meaning of exporters. It would also be good to include examples of how you see the exporter interfaces of TLS libraries changing as a result. eg, are we introducing key epochs here? How does [this](https://pkg.go.dev/crypto/tls#ConnectionState.ExportKeyingMaterial) or [this](https://learn.microsoft.com/en-us/windows/win32/seccng/sslexportkeyingmaterial) look like after this change?\n\n- How and whether tickets work across extended key updates. I guess once the resumption secret is rolled, then we can send a new batch of tickets using the new keys, but if the previously-sent tickets are still accepted then this RFC doesn't really meet its goal (since that resumption would \"rewind\" the session keying back to the compromised ones). One option would be to require stateful resumption, with all the deployment difficulties that come with it. Note we can't just say \"clients must delete previously-received tickets after an extended key update\", because the threat model here is that the peers have failed to keep secrets.",
          "createdAt": "2025-07-05T17:12:45Z",
          "updatedAt": "2025-07-05T17:12:45Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this is a big change for the key exporter. Unfortunately, we need this functionality whenever we use TLS as a key management protocol for some other protocol. It is not clear to me why the key exporter in TLS 1.3 does not modify the keys when it performs a key update.",
          "createdAt": "2025-07-06T18:24:24Z",
          "updatedAt": "2025-07-06T18:24:24Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW I added text about the ticket-based exchange.\n\nI believe that noting that \"clients must delete previously-received tickets after an extended key update\" is a solution. Of course, the ticket storage adds extra risks since these keys need to be stored somewhere. If that is a concern, then using the tickets might be not be the right solution.",
          "createdAt": "2025-07-07T08:34:05Z",
          "updatedAt": "2025-07-07T08:34:05Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I leave this issue open althrough I provided an update to the draft. Based on the feedback from Joe I believe more text is needed.",
          "createdAt": "2025-07-07T13:13:11Z",
          "updatedAt": "2025-07-07T13:13:11Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "With resumption secret, it is at least possible to make things work by defining the secret to be directional from server to client, since tickets are sent by server as handshake messages, and thus ordered with EKU.\n\nHowever, the exporter secret is fundamentally non-directional, and tied to application data, which is unordered relative to handshake messages (especially when running over unreliable transport); moreover, key updates are fundamentally directional. Merely notifying application on exporter secret changes does not work (which would already require explicit opt-in by application), the mechanism would require explicit protocol-level support (which no current protocol has). This is because current protocols assume that exporter yields the same results without regard to timing or endpoint, so changing the exporter secret mid-connection causes Undefined Behavior (which is not acceptable).\n\nAnd even having explicit epochs and the required protocol support would pose challenges with epoch management, as the keys must be kept as long as the application protocol is willing to re-transmit any application messages that depend on exporters.\n\n",
          "createdAt": "2025-09-07T16:42:32Z",
          "updatedAt": "2025-09-07T16:42:32Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOMJPqLM63ncQQ",
      "title": "Update IANA Consideration Section",
      "url": "https://github.com/tlswg/tls-key-update/issues/21",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Not all messages are registered:\n- NewKeyUpdate\n- ExtendedKeyUpdateRequest\n- ExtendedKeyUpdateResponseStatus",
      "createdAt": "2025-05-21T15:09:14Z",
      "updatedAt": "2025-07-07T13:12:15Z",
      "closedAt": "2025-07-07T13:12:15Z",
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is the relevant PR: https://github.com/tlswg/tls-key-update/pull/31\n",
          "createdAt": "2025-07-05T15:13:04Z",
          "updatedAt": "2025-07-05T15:13:04Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOMJPqLM63n5gO",
      "title": "Extended Key Update replaces regular Key Update",
      "url": "https://github.com/tlswg/tls-key-update/issues/22",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add text in the document.",
      "createdAt": "2025-05-21T15:41:34Z",
      "updatedAt": "2025-07-07T13:12:02Z",
      "closedAt": "2025-07-07T13:12:02Z",
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "Is that feasible / necessary? The Key Update as contained should be suitable for many connections, which are not long lasting to update the exisiting session key. Requiring support for extended key update in each case may increase processing effort even though the connection is not long lived.",
          "createdAt": "2025-05-30T14:03:35Z",
          "updatedAt": "2025-05-30T14:03:35Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Michael added that we need text to describe how a party behaves when the peer misbehaves and transits a regular Key Update",
          "createdAt": "2025-06-03T17:22:10Z",
          "updatedAt": "2025-06-03T17:22:10Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Assumption: Key Update and Extended Key Update can be both used simultaneously",
          "createdAt": "2025-06-03T17:23:39Z",
          "updatedAt": "2025-06-03T17:23:39Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "PR https://github.com/tlswg/tls-key-update/pull/30/ says that the extended key update, when negotiated, replaces the regular key update. ",
          "createdAt": "2025-07-05T14:41:51Z",
          "updatedAt": "2025-07-05T14:41:51Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOMJPqLM63n7H_",
      "title": "Describe epoch handling in DTLS",
      "url": "https://github.com/tlswg/tls-key-update/issues/23",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 8 is quite short and does not cover this topic in detail",
      "createdAt": "2025-05-21T15:43:11Z",
      "updatedAt": "2025-08-29T13:41:09Z",
      "closedAt": "2025-08-29T13:41:09Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOMJPqLM63n82D",
      "title": "Add ACK to final NewKeyUpdate for DTLS",
      "url": "https://github.com/tlswg/tls-key-update/issues/24",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T15:45:50Z",
      "updatedAt": "2025-08-29T13:41:16Z",
      "closedAt": "2025-08-29T13:41:16Z",
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Add a message exchange to the DTLS 1.3 section",
          "createdAt": "2025-07-07T13:14:21Z",
          "updatedAt": "2025-07-07T13:14:21Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOMJPqLM63oBjA",
      "title": "Add annotation to figures identifying the utilized key",
      "url": "https://github.com/tlswg/tls-key-update/issues/25",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-21T15:52:55Z",
      "updatedAt": "2025-07-07T13:11:54Z",
      "closedAt": "2025-07-07T13:11:54Z",
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Add:\n\n>    +  Indicates noteworthy extensions sent in the\n> \t  previously noted message.\n> \n>    *  Indicates optional or situation-dependent\n> \t  messages/extensions that are not always sent.\n> \n>    () Indicates messages protected using keys\n> \t  derived from a client_early_traffic_secret.\n> \n>    {} Indicates messages protected using keys\n> \t  derived from a [sender]_handshake_traffic_secret.\n> \n>    [] Indicates messages protected using keys\n> \t  derived from [sender]_application_traffic_secret_N.\n",
          "createdAt": "2025-05-21T15:54:41Z",
          "updatedAt": "2025-05-21T15:55:35Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "PR is here: https://github.com/tlswg/tls-key-update/pull/35\n",
          "createdAt": "2025-07-07T08:41:26Z",
          "updatedAt": "2025-07-07T08:41:26Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOMJPqLM641bLv",
      "title": "Term \"Forward Secrecy\" is confusing",
      "url": "https://github.com/tlswg/tls-key-update/issues/26",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rewrite introduction to better explain the security objective",
      "createdAt": "2025-05-29T17:33:54Z",
      "updatedAt": "2025-07-05T14:34:50Z",
      "closedAt": "2025-07-05T14:34:50Z",
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "Hm, I actually find the text not confusing actuall. In addition to what is stated there, we may also refer to [RFC 4949](https://datatracker.ietf.org/doc/html/rfc4949) for this term to avoid redefining it and mke people aware, that there has been already a dicussion on the terminology.\n",
          "createdAt": "2025-05-30T13:59:16Z",
          "updatedAt": "2025-05-30T13:59:16Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Yaroslav suggests \"Intra-Session Forward Secrecy\" ",
          "createdAt": "2025-06-03T17:52:11Z",
          "updatedAt": "2025-06-03T17:52:11Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "The paper on \"On Post-Compromise Security\" talks about long-term secrets getting exposed, which is not what we are not focusing on.",
          "createdAt": "2025-06-03T17:53:27Z",
          "updatedAt": "2025-06-03T17:53:27Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "When using extended key update an attacker has to perform a dynamic key exfiltration attack. See definition of dynamic key exfiltration in https://datatracker.ietf.org/doc/html/rfc7624\n",
          "createdAt": "2025-06-03T17:55:26Z",
          "updatedAt": "2025-06-03T17:55:26Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed the text in the introduction (see https://github.com/tlswg/tls-key-update/pull/29) and the abstract (see https://github.com/tlswg/tls-key-update/pull/28) to focus on the dynamic key exfiltration topic.\n\nPCS does not appear to be the right term for what we are looking at.",
          "createdAt": "2025-07-05T14:29:09Z",
          "updatedAt": "2025-07-05T14:29:09Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOMJPqLM65PVfR",
      "title": "Missing references in introduction",
      "url": "https://github.com/tlswg/tls-key-update/issues/27",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> For IPsec, US NIST, German BSI, and French ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward secrecy and force attackers to perform a dynamic key exfiltration [[RFC7624](https://tlswg.org/tls-key-update/draft-ietf-tls-extended-key-update.html#RFC7624)].\n\nThe mentioned reference RFC 7624 does not mention US NIST, German BSI, and French ANSSI. So this claim needs to be justified by corresponding references from US NIST, German BSI and French ANSSI. \n\nThe reference for French ANSSI is given in the next sentence, but references for US NIST and German BSI are missing. ",
      "createdAt": "2025-06-01T20:23:44Z",
      "updatedAt": "2025-09-07T09:53:57Z",
      "closedAt": "2025-09-07T09:53:57Z",
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Rewrote the introduction in https://github.com/tlswg/tls-key-update/pull/29 and included only the reference to ANSSI. It is just an example and we do not have to be exhaustive.",
          "createdAt": "2025-07-05T14:27:45Z",
          "updatedAt": "2025-07-05T14:27:45Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Rewrote the introduction in https://github.com/tlswg/tls-key-update/pull/29 and included only the reference to ANSSI.\n\nThe given [ref](https://cyber.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf) for ANSSI is broken. \n\n> It is just an example and we do not have to be exhaustive.\n\nSure, but there should be at least one justified example.",
          "createdAt": "2025-09-01T20:04:07Z",
          "updatedAt": "2025-09-01T20:04:07Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed reference",
          "createdAt": "2025-09-07T09:53:57Z",
          "updatedAt": "2025-09-07T09:53:57Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOMJPqLM7IrO5V",
      "title": "Remove \"Clashed\"",
      "url": "https://github.com/tlswg/tls-key-update/issues/41",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tiru wrote: I like the suggestion from Ekr to remove clashed, see his comment below:\n\nI see what \"clashed\" is trying to do, but I think there's another\nopportunity to simplify: because you are determining which side wins\nbased on information known both sides, they can each independently\ndetermine which EKURequest will be accepted and which one will be\nrejected [0]. So instead of having the winner send a EKUResponse\nrejecting the loser, I suggest it just wait for the EKUResponse\nfrom the loser. I.e.,\nClient Server\n\nEKURequest(share=1) -> <- EKURequest(share=2)\n[ignores EKURequest]\nEKUResponse(share=1) ->\n\nThis removes one message and simplifies the state machine because the\nlosing Initiator can transition directly to sending EKUResponse\nwithout having to have a state waiting for the EKUResponse(clashed)\nmessage.",
      "createdAt": "2025-08-29T12:48:31Z",
      "updatedAt": "2025-09-17T19:18:11Z",
      "closedAt": "2025-09-17T19:18:11Z",
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, the proposal to avoid the \"clashed\" is fine from my understanding and would reduce the number of states. \nAlso, when indicating the share in the response message, it is easy to identify the matching request. \nGiven the above, I would have expected the call flow differently, at least the response from the client would be a reaction on the  server provided share(2):\n~~~~\nClient                                       Server\n---------------------------------------------------\nEKURequest(share=1) ->       <- EKURequest(share=2)\n                               [ignores EKURequest]\nEKUResponse(share=2) ->\n~~~~\n\nIf I understand ecr right, avoiding to send EKUResponse(share=1) informs the client that share=1 has not been taken res. if the client sends EKUResponse(share=2) it would essentiall frop its own proposal and take the server's proposal instead. \n\nCould this lead to a race condition, if both accept the other side's proposal?\n",
          "createdAt": "2025-09-01T14:41:21Z",
          "updatedAt": "2025-09-01T14:41:21Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "I do not think there is any need to indicate which share peer is responding to, because there can only ever be one outstanding EKU in progress. And if the winner is determined by some criteria that only depends on EKURequest contents and client/server roles, it is not possible to get into situation where both peers accept or both peers reject.\n\nWhen using DTLS (i.e., unreliable transport), the winner will still need to explicitly acknowledge the EKURequest from the loser, as there is no explicit reply message. Also, peer might still need to re-transmit EKURequest even after determining it will be the winner (until the loser acknowledges the EKURequest either via explicit ACK, or EKUResponse).\n\nHowever, there might be bad interactions with refusing EKU. I think it should be required that the loser MUST NOT refuse EKU. Refusing EKU is meant for handling overload, and a peer that starts EKU process is expected to be able to complete it.",
          "createdAt": "2025-09-07T15:10:06Z",
          "updatedAt": "2025-09-07T15:10:06Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in https://github.com/tlswg/tls-key-update/pull/53",
          "createdAt": "2025-09-07T19:32:27Z",
          "updatedAt": "2025-09-07T19:32:27Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOMJPqLM7KGOWH",
      "title": "Move State Machines to the Appendix",
      "url": "https://github.com/tlswg/tls-key-update/issues/45",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As it is, for instance, done in https://datatracker.ietf.org/doc/html/rfc8446#appendix-A.1",
      "createdAt": "2025-09-06T18:02:27Z",
      "updatedAt": "2025-09-07T10:32:48Z",
      "closedAt": "2025-09-07T10:32:48Z",
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "See PR #49 ",
          "createdAt": "2025-09-07T09:54:17Z",
          "updatedAt": "2025-09-07T09:54:17Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOMJPqLM7KGP0U",
      "title": "Explain interactions with other handshake messages",
      "url": "https://github.com/tlswg/tls-key-update/issues/46",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently we only talk about application data payloads being accepted during the different extended key update states.",
      "createdAt": "2025-09-06T18:05:00Z",
      "updatedAt": "2026-01-14T05:05:46Z",
      "closedAt": "2026-01-14T05:05:45Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point, I propose to add the following text:\nOnce the Extended Key Update mechanism is complete and the endpoint begins using the corresponding traffic keys, all records are encrypted with those keys, including alerts and post-handshake messages.",
          "createdAt": "2025-11-13T10:48:16Z",
          "updatedAt": "2025-11-13T10:48:16Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in https://github.com/tlswg/tls-key-update/pull/92",
          "createdAt": "2026-01-14T05:05:45Z",
          "updatedAt": "2026-01-14T05:05:45Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOMJPqLM7KGQCy",
      "title": "Add state machine for TLS 1.3",
      "url": "https://github.com/tlswg/tls-key-update/issues/47",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Done with PR #51 ",
      "createdAt": "2025-09-06T18:05:25Z",
      "updatedAt": "2025-10-30T16:30:50Z",
      "closedAt": "2025-10-30T16:30:50Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOMJPqLM7KJMqS",
      "title": "Steps #3 und #5 in DTLS 1.3 Considerations need more text",
      "url": "https://github.com/tlswg/tls-key-update/issues/48",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tiru wrote: \n\n> Step 3 does not specify what happens when the status in ExtendedKeyUpdate(response) is not set to \"accepted\". I don\u2019t see a need for Step 3, since the responder must send an ExtendedKeyUpdate(response) regardless of whether the status is \"accepted\" or not.\n\n> 5. The initiator transmits an `ExtendedKeyUpdate(new_key_update)` message. This message also serves as an implicit acknowledgment of the responder\u2019s ExtendedKeyUpdate(response), so no separate ACK is required.",
      "createdAt": "2025-09-07T09:29:32Z",
      "updatedAt": "2025-10-30T16:31:23Z",
      "closedAt": "2025-10-30T16:31:23Z",
      "comments": []
    },
    {
      "number": 55,
      "id": "I_kwDOMJPqLM7MS7b2",
      "title": "Clashing requests with equal keyshare",
      "url": "https://github.com/tlswg/tls-key-update/issues/55",
      "state": "CLOSED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed, an artificial clash with a reflected key share could be used to confuse the peer. We should spell out that this is an incorrect behaviour.",
      "createdAt": "2025-09-17T19:19:34Z",
      "updatedAt": "2025-10-13T06:55:30Z",
      "closedAt": "2025-10-13T06:55:30Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in https://github.com/tlswg/tls-key-update/pull/62",
          "createdAt": "2025-10-13T06:55:30Z",
          "updatedAt": "2025-10-13T06:55:30Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOMJPqLM7MS8FX",
      "title": "DTLS retransmit",
      "url": "https://github.com/tlswg/tls-key-update/issues/56",
      "state": "CLOSED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to clarify who retransmits what in DTLS flows in case there is a suspicion that a message was lost.",
      "createdAt": "2025-09-17T19:20:24Z",
      "updatedAt": "2026-01-14T05:05:24Z",
      "closedAt": "2026-01-14T05:05:23Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "we can add the following line:\nRetransmission of Extended Key Update messages in DTLS follows the DTLS handshake retransmission procedure.",
          "createdAt": "2025-11-13T10:53:22Z",
          "updatedAt": "2025-11-13T10:53:22Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in https://github.com/tlswg/tls-key-update/pull/92.",
          "createdAt": "2026-01-14T05:05:24Z",
          "updatedAt": "2026-01-14T05:05:24Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOMJPqLM7MS8Ww",
      "title": "DoS security considerations",
      "url": "https://github.com/tlswg/tls-key-update/issues/57",
      "state": "CLOSED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should add DoS security considerations",
      "createdAt": "2025-09-17T19:20:44Z",
      "updatedAt": "2025-10-13T06:55:17Z",
      "closedAt": "2025-10-13T06:55:17Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in https://github.com/tlswg/tls-key-update/pull/62",
          "createdAt": "2025-10-13T06:55:17Z",
          "updatedAt": "2025-10-13T06:55:17Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOMJPqLM7PXeV7",
      "title": "Ambiguities in current editor's draft",
      "url": "https://github.com/tlswg/tls-key-update/issues/59",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### 0. General comments:\n- s/Master Secret/Main Secret (to be consistent with [RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html))\n- Clarify all uses of \"traffic keys\" to specify whether that means `handshake_traffic_secret`, `application_traffic_secret`, or something else.\n\n---\n### 1. Threat model \n- Clarify the threat model: Precisely which keys are compromised and how?\n  - Is `application_traffic_secret` compromised because of the compromise of (EC)DHE shared secret `g^xy` or something else?\n  - Is `handshake_traffic_secret` compromised or not? If yes, which one: client or server or both?\n  - LTK is not compromised. (This was clarified [here](https://github.com/tlswg/tls-key-update/pull/58#issuecomment-3353027736), Thank you Hannes)\n\n---\n### 2. Informal security goals\nStating the following is insufficient. \n> \"This entire document is about security.\"\n- State as clearly as possible what do you want to achieve with this spec, such that with formal analysis it can be checked whether these goals are met or not. \n\n---\n### 3. Protocol diagram\n- Define `SEND keys` and `RECEIVE keys` precisely as used in [Figure 3 in the current editor's draft](https://tlswg.org/tls-key-update/draft-ietf-tls-extended-key-update.html#figure-3).\n- State machines in Appendix B: DTLS state machines have some explanation, but an explanation is missing for TLS state machines. ",
      "createdAt": "2025-10-02T21:40:51Z",
      "updatedAt": "2025-10-20T08:58:12Z",
      "closedAt": "2025-10-20T08:58:12Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Security considerations in updated in https://github.com/tlswg/tls-key-update/pull/62",
          "createdAt": "2025-10-13T06:59:13Z",
          "updatedAt": "2025-10-13T06:59:13Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOMJPqLM7SuzNf",
      "title": "Ambiguities in version -06",
      "url": "https://github.com/tlswg/tls-key-update/issues/67",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[A follow-up of #59 since it was closed by the authors without being properly addressed]\n\n### 0. General comments:\n- Make the names of keys consistent with [RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html), and define any new ones very clearly. For example, I cannot parse `exporter_main_secret`. What is it? Why is it required?\n- Clarify all unqualified uses of \"traffic keys\" to specify whether that means `handshake_traffic_secret`, `application_traffic_secret`, or something else.\n- Section 11.1 and 11.2 are ditto copy.\n\n---\n### 1. Threat model \n- Clarify the threat model: Precisely which keys are compromised and **how**? See [here](https://mailarchive.ietf.org/arch/msg/tls/P_VdWSi20TZG0rJEaz7VCPKDIOg/) why the \"how\" part is necessary. [Sec. 11.1](https://www.ietf.org/archive/id/draft-ietf-tls-extended-key-update-06.html#section-11.1) says \n\n> compromise of the current application traffic secrets\n\nWhat exactly does that entail? Does that mean `client_application_traffic_secret_0` and `server_application_traffic_secret_0`?\n\n  - Is `application_traffic_secret` compromised because of the compromise of (EC)DHE shared secret `g^xy` or something else?\n  - Is `handshake_traffic_secret` compromised or not? If yes, which one: client or server or both?\n  - Is `g^xy` compromised or not?\n\n---\n### 2. Informal security goals\n\n- State as clearly as possible what do you want to achieve with this spec, such that with formal analysis it can be checked whether these goals are met or not. \n\n---\n### 3. Protocol diagram and state machine\n- TLS state machines in Appendix B.2 and B.3 are very hard to read for me. Some symbols are undefined, and an explanation is missing. For example, what is (A) and (B)? There is (1), (2), (4) and (5): is there a reason for having no (3)?",
      "createdAt": "2025-10-21T08:18:34Z",
      "updatedAt": "2025-10-26T08:15:34Z",
      "closedAt": "2025-10-26T08:15:34Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "I created 4 new issues for better tracking and discussion. ",
          "createdAt": "2025-10-26T08:15:34Z",
          "updatedAt": "2025-10-26T08:15:34Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOMJPqLM7TzXP5",
      "title": "General comments",
      "url": "https://github.com/tlswg/tls-key-update/issues/69",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### 0. General comments:\n- Make the names of keys consistent with [RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html), and define any new ones very clearly. For example, I cannot parse `exporter_main_secret`. What is it? Why is it required?\n- Clarify all unqualified uses of \"traffic keys\" to specify whether that means `handshake_traffic_secret`, `application_traffic_secret`, or something else.\n- Section 11.1 and 11.2 are ditto copy.",
      "createdAt": "2025-10-26T08:13:28Z",
      "updatedAt": "2025-10-27T04:56:07Z",
      "closedAt": "2025-10-27T04:56:07Z",
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOMJPqLM7TzXcY",
      "title": "Threat Model",
      "url": "https://github.com/tlswg/tls-key-update/issues/70",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### 1. Threat model \n- Clarify the threat model: Precisely which keys are compromised and **how**? See [here](https://mailarchive.ietf.org/arch/msg/tls/P_VdWSi20TZG0rJEaz7VCPKDIOg/) why the \"how\" part is necessary. [Sec. 11.1](https://www.ietf.org/archive/id/draft-ietf-tls-extended-key-update-06.html#section-11.1) says \n\n> compromise of the current application traffic secrets\n\nWhat exactly does that entail? Does that mean `client_application_traffic_secret_0` and `server_application_traffic_secret_0`?\n\n  - Is `application_traffic_secret` compromised because of the compromise of (EC)DHE shared secret `g^xy` or something else?\n  - Is `handshake_traffic_secret` compromised or not? If yes, which one: client or server or both?\n  - Is `g^xy` compromised or not?",
      "createdAt": "2025-10-26T08:13:53Z",
      "updatedAt": "2025-10-27T04:56:16Z",
      "closedAt": "2025-10-27T04:56:16Z",
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOMJPqLM7TzXjV",
      "title": "Informal security goals",
      "url": "https://github.com/tlswg/tls-key-update/issues/71",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### 2. Informal security goals\n\n- State as clearly as possible what do you want to achieve with this spec, such that with formal analysis it can be checked whether these goals are met or not. ",
      "createdAt": "2025-10-26T08:14:06Z",
      "updatedAt": "2025-10-27T04:55:59Z",
      "closedAt": "2025-10-27T04:55:59Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "These are security goals:\n\n1. Post-Compromise Security (PCS), it is discussed in Section 11.1\n2. Key Freshness and Independence: Each Extended Key Update derives new application traffic secrets from freshly generated ephemeral key exchange material, ensuring cryptographic independence from previous secrets.\n3.  Application data protected under previous keys cannot be decrypted using secrets derived from subsequent updates and vice versa.\n4. Once Extended Key Update is negotiated, peers do not accept the standard KeyUpdate mechanism within the same session.",
          "createdAt": "2025-10-26T08:30:57Z",
          "updatedAt": "2025-10-26T08:30:57Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOMJPqLM7TzX1v",
      "title": "Protocol diagram and state machine",
      "url": "https://github.com/tlswg/tls-key-update/issues/72",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### 3. Protocol diagram and state machine\n- TLS state machines in Appendix B.2 and B.3 are very hard to read for me. Some symbols are undefined, and an explanation is missing. For example, what is (A) and (B)? There is (1), (2), (4) and (5): is there a reason for having no (3)?",
      "createdAt": "2025-10-26T08:14:31Z",
      "updatedAt": "2025-10-27T04:55:51Z",
      "closedAt": "2025-10-27T04:55:51Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOMJPqLM7T5iOc",
      "title": "Exporter API",
      "url": "https://github.com/tlswg/tls-key-update/issues/74",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ ilaril raised the following comments in https://github.com/tlswg/tls-key-update/pull/66:\n\n\n===\nI can not give specific modifications, because I am not sure what I have in mind actually works (this is something so complex that one would need to formally model it to know what could possibly go wrong). I only know what does not work.\n\nFirstly, this can not work with the present TLS exporter interface, because the exporter is not directional, and it is impossible to synchronize updates in the general case (and even special cases are far beyond what TLS can do). One would have define new TLS exporter interface with epoch as explicit input in order to get around this problem.\n\nSecondly, epoch change notifications (even if local and remote) are not sufficient, because the epoch can change between application using exporter and transmitting the data, leading to receiver inferring incorrect epoch. One would have to define some interface allowing application to freeze epoch updates.\n\nThese two problems are independent of any re-ordering or packet loss, so can happen with TLS, not just DTLS.\n\nThen there might be a third problem I am not thinking of... Or there might be a problem with the solution given to the second problem that only appears in DTLS, which allows re-ordering or packet loss.\n\nAnd even if this could be made to work, the interface changes are quite high cost to any application that uses TLS exporters.\n",
      "createdAt": "2025-10-27T05:07:20Z",
      "updatedAt": "2025-11-03T06:35:58Z",
      "closedAt": "2025-11-03T06:35:58Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in https://github.com/tlswg/tls-key-update/pull/80",
          "createdAt": "2025-11-03T06:35:58Z",
          "updatedAt": "2025-11-03T06:35:58Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOMJPqLM7T67PV",
      "title": "General comments on version -06",
      "url": "https://github.com/tlswg/tls-key-update/issues/75",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[A follow-up of #59 since it was closed by the authors without being properly addressed]\n\n[Opening separate issues as requested by the authors]\n \n- Make the names of keys consistent with [RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html), and define any new ones very clearly. For example, I cannot parse `exporter_main_secret`. What is it? Why is it required?\n- Clarify all unqualified uses of \"traffic keys\" to specify whether that means `handshake_traffic_secret`, `application_traffic_secret`, or something else.",
      "createdAt": "2025-10-27T07:31:16Z",
      "updatedAt": "2025-11-03T06:36:10Z",
      "closedAt": "2025-11-03T06:36:10Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed these issues https://github.com/tlswg/tls-key-update/pull/73, please check.",
          "createdAt": "2025-10-28T05:38:40Z",
          "updatedAt": "2025-10-28T05:38:40Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for updates. Have you thoroughly checked that all other keys are consistent with RFC8446bis?",
          "createdAt": "2025-10-28T20:43:52Z",
          "updatedAt": "2025-10-28T20:43:52Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "I\u2019ve checked, but it\u2019s possible I may have missed something. In any case, the priority right now is to address all pending issues that need WG attention before revisiting this.",
          "createdAt": "2025-10-29T06:40:52Z",
          "updatedAt": "2025-10-29T06:40:52Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, take your time. When you think you are fully aligned with RFC8446bis, let me know.",
          "createdAt": "2025-10-29T11:45:50Z",
          "updatedAt": "2025-10-29T11:45:50Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed https://github.com/tlswg/tls-key-update/pull/80 as per our meeting yestarday.",
          "createdAt": "2025-10-30T05:35:43Z",
          "updatedAt": "2025-10-30T05:35:43Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOMJPqLM7T69Mb",
      "title": "Ambiguities in version -06: Threat model",
      "url": "https://github.com/tlswg/tls-key-update/issues/76",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[A follow-up of #59 since it was closed by the authors without being properly addressed]\n\n[Opening separate issues as requested by the authors]\n\n- Clarify the threat model: Precisely which keys are compromised and **how**? See [here](https://mailarchive.ietf.org/arch/msg/tls/P_VdWSi20TZG0rJEaz7VCPKDIOg/) why the \"how\" part is necessary. [Sec. 11.1](https://www.ietf.org/archive/id/draft-ietf-tls-extended-key-update-06.html#section-11.1) says \n\n> compromise of the current application traffic secrets\n\nWhat exactly does that entail? Does that mean `client_application_traffic_secret_0` and `server_application_traffic_secret_0`?\n\n  - Is `application_traffic_secret` compromised because of the compromise of (EC)DHE shared secret `g^xy` or something else?\n  - Is `handshake_traffic_secret` compromised or not? If yes, which one: client or server or both?\n  - Is `g^xy` compromised or not?",
      "createdAt": "2025-10-27T07:33:51Z",
      "updatedAt": "2025-11-03T06:36:26Z",
      "closedAt": "2025-11-03T06:36:26Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed these issues https://github.com/tlswg/tls-key-update/pull/73, please check.",
          "createdAt": "2025-10-28T05:38:51Z",
          "updatedAt": "2025-10-28T05:38:51Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the updates. I don't find an answer to my question.  \n> Is g^xy compromised or not?\n\nAm I missing something? \n\n---\n\nAbout the text in PR:\n> short-term exposure of system memory or TLS session state after the handshake has completed\n\nIs it realistic to have memory exposure where only session state is exposed (and the LTK is not exposed)?",
          "createdAt": "2025-10-28T21:11:43Z",
          "updatedAt": "2025-10-28T21:11:43Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks for the updates. I don't find an answer to my question.\n> \n> > Is g^xy compromised or not?\n> \n> Am I missing something?\n\nThe below text covers it:\n\nIf a compromise occurs before the handshake completes, **the ephemeral key exchange**, client_handshake_traffic_secret, and server_handshake_traffic_secret could be exposed.\n\nThe ephemeral key exchange covers both traditional and PQC KEMs.\n\n> \n> About the text in PR:\n> \n> > short-term exposure of system memory or TLS session state after the handshake has completed\n> \n> Is it realistic to have memory exposure where only session state is exposed (and the LTK is not exposed)?\n\nYes, private keys would be stored in TEE/HSM whereas ephemeral keys are stored in the rich OS.",
          "createdAt": "2025-10-29T06:01:29Z",
          "updatedAt": "2025-10-29T06:01:29Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't find even a single instance of TEE, HSM, OS in -06 or #73. Please clarify both items in the draft. ",
          "createdAt": "2025-10-29T07:18:16Z",
          "updatedAt": "2025-10-29T07:18:16Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "In a meeting with @tireddy2, @tuexen and @yaroslavros, authors agreed that the text will be added in the draft for clarification of the system model.",
          "createdAt": "2025-10-29T12:12:32Z",
          "updatedAt": "2025-10-29T12:12:32Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed issue in https://github.com/tlswg/tls-key-update/pull/80. ",
          "createdAt": "2025-10-30T05:35:15Z",
          "updatedAt": "2025-10-30T05:35:15Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOMJPqLM7T6-BT",
      "title": "Ambiguities in version -06: Informal security goals",
      "url": "https://github.com/tlswg/tls-key-update/issues/77",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[A follow-up of #59 since it was closed by the authors without being properly addressed]\n\n[Opening separate issues as requested by the authors]\n\n- State as clearly as possible what do you want to achieve with this spec, such that with formal analysis it can be checked whether these goals are met or not.",
      "createdAt": "2025-10-27T07:35:05Z",
      "updatedAt": "2026-01-06T14:06:09Z",
      "closedAt": "2026-01-06T14:06:09Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "These are security goals:\n1.  Post-Compromise Security (PCS), it is discussed in Section 11.1\n2.  Key Freshness and Independence: Each Extended Key Update derives new application traffic secrets from freshly generated ephemeral key exchange material, ensuring cryptographic independence from previous secrets.\n3.  Application data protected under previous keys cannot be decrypted using secrets derived from subsequent updates and vice versa.\n4.  Once Extended Key Update is negotiated, peers do not accept the standard KeyUpdate mechanism within the same session.\n",
          "createdAt": "2025-10-28T05:39:50Z",
          "updatedAt": "2025-10-28T05:40:36Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Please add those goals in the draft. ",
          "createdAt": "2025-10-28T14:41:25Z",
          "updatedAt": "2025-10-28T14:41:25Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there any guidance on adding informal security goals to TLS drafts?\nCould you please point me to a few drafts that have included such goals for reference ?",
          "createdAt": "2025-10-29T06:42:51Z",
          "updatedAt": "2025-10-29T06:42:51Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there any guidance on adding informal security goals to TLS drafts?\n\nI started creating such a [guidance](https://www.ietf.org/archive/id/draft-usama-tls-fatt-extension-00.html#section-3.2). I will come back to it. \n\n> Could you please point me to a few drafts that have included such goals for reference ?\n\n[RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html#appendix-F) should provide a good reference. There are surely others.",
          "createdAt": "2025-10-29T07:02:47Z",
          "updatedAt": "2025-10-29T07:02:47Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "In a meeting with @tireddy2, @tuexen and @yaroslavros, authors agreed that the security goals (after refinement) will be added to the draft, maybe in Appendix like [RFC8446bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-14.html#appendix-F).",
          "createdAt": "2025-10-29T11:53:47Z",
          "updatedAt": "2025-10-29T11:53:47Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOMJPqLM7T6-YU",
      "title": "Ambiguities in version -06: Protocol diagram and state machine",
      "url": "https://github.com/tlswg/tls-key-update/issues/78",
      "state": "CLOSED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[A follow-up of #59 since it was closed by the authors without being properly addressed]\n\n[Opening separate issues as requested by the authors]\n\n- TLS state machines in Appendix B.2 and B.3 are very hard to read for me. Some symbols are undefined, and an explanation is missing. For example, what is (A) and (B)? There is (1), (2), (4) and (5): is there a reason for having no (3)?",
      "createdAt": "2025-10-27T07:35:36Z",
      "updatedAt": "2026-01-14T05:04:47Z",
      "closedAt": "2026-01-14T05:04:47Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "In a meeting with @tireddy2, @tuexen and @yaroslavros, authors also found it to be confusing and couldn't recall what it means. There are some unusual conventions, for example, there is `SENT_NKU / WAIT_R_NKU` in one box. Is it something other than state name?\n\n@hannestschofenig has been working on it and will update these state machines, and add some explanation. ",
          "createdAt": "2025-10-29T12:10:47Z",
          "updatedAt": "2025-10-29T12:10:47Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I ran out of time before the cutoff and submitted the snapshot we had. Thought it was better than the out-of-date version.\n\nWill update it during the hackathon!",
          "createdAt": "2025-10-29T20:30:29Z",
          "updatedAt": "2025-10-29T20:30:29Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Many thanks, Hannes.",
          "createdAt": "2025-10-29T21:22:56Z",
          "updatedAt": "2025-10-29T21:22:56Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannestschofenig - We will clarify that the Appendix state diagrams are illustrative, and the normative text in the draft takes precedence in case of conflict.",
          "createdAt": "2025-10-30T11:41:59Z",
          "updatedAt": "2025-10-30T11:41:59Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see anything in flight on clarification of TLS state machines. Did I miss something?",
          "createdAt": "2025-11-22T10:06:41Z",
          "updatedAt": "2025-11-22T10:06:41Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed inhttps://github.com/tlswg/tls-key-update/pull/93.",
          "createdAt": "2026-01-14T05:04:47Z",
          "updatedAt": "2026-01-14T05:04:47Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOMJPqLM7UgtWc",
      "title": "Align labels with 8446",
      "url": "https://github.com/tlswg/tls-key-update/issues/79",
      "state": "CLOSED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RFC8446/8446bis uses \"derived\" as a label while for some reason current draft uses \"key derived\". I think we should align.\n\n<img width=\"328\" height=\"57\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/46337600-a032-4d40-8d22-554866782412\" />\n\n<img width=\"344\" height=\"66\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/c9cb9b8a-03b8-49a8-a7c8-904e7015913d\" />\n\nWe also should align on other labels. I don't see any value in adding \"2\" and changing \"master\" to \"main\" inside HKDF label which would bring us out of sync with the main TLS 1.3 spec.",
      "createdAt": "2025-10-29T10:39:34Z",
      "updatedAt": "2025-11-03T06:35:25Z",
      "closedAt": "2025-11-03T06:35:25Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in https://github.com/tlswg/tls-key-update/pull/80 ",
          "createdAt": "2025-10-30T05:34:31Z",
          "updatedAt": "2025-10-30T05:34:31Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOMJPqLM7VrUFd",
      "title": "Key schedule",
      "url": "https://github.com/tlswg/tls-key-update/issues/83",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Then while writing this, I noticed that it is also unclear how the EKU key schedule connects to the main TLS key schedule. I guess Main Secret 0 is the same as TLS Main Secret (and exporter_secret_0 would be the same as exporter_secret). And noted that instead of having to steal both active application traffic keys for catastrophic compromise, it suffices to steal just the active main secret (which now has to be kept in memory, and thus vulnerable to compromise).\n\nAlso, the messages do not seem to be hashed before being fed to key schedule, which results shares being hashed four times, which gets painful with post-quantum stuff. And the reasoning mentions MAL-BIND-K-CT security, any of the MAL-* models are completely irrelevant to TLS.",
      "createdAt": "2025-11-04T06:15:05Z",
      "updatedAt": "2025-11-05T06:23:35Z",
      "closedAt": "2025-11-05T06:23:35Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "a) The diagram follows the same convention as TLS 1.3 key schedule in RFC8446, where the listed messages represent the transcript hash of those messages, not the raw message bytes. Re-using the computed transcript hash is an implementation optimization and not part of the protocol definition. I don't see any such optimization discussed in RFC8446. \n\nb) please clarify why MAL-* models are not applicable to TLS ?\n\nc) The main issue is already discussed in Updating Traffic Secrets Section, see snip below:\n\nDuring the initial handshake, the Main Secret is generated (see\n{{Section 7.1 of TLS}}). Since the Main Secret\nis discarded during the key derivation procedure, a derived value is\nstored. This stored value then serves as the input salt to the first\nkey update procedure that incorporates the ephemeral (EC)DHE-\nestablished value as input keying material (IKM) to produce\nmain_secret_{N+1}. The derived value from this new master secret\nserves as input salt to the subsequent key update procedure, which\nalso incorporates a fresh ephemeral (EC)DHE value as IKM. This\nprocess is repeated for each additional key update procedure.\n",
          "createdAt": "2025-11-04T08:44:59Z",
          "updatedAt": "2025-11-04T08:44:59Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "> a) The diagram follows the same convention as TLS 1.3 key schedule in RFC8446, where the listed messages represent the transcript hash of those messages, not the raw message bytes.\n\nI find this unclear. Searching for \"transcript\" gives no hits, \"hash\" only gives one irrelevant one.\n\n> b) please clarify why MAL-* models are not applicable to TLS ?\n\nEven LEAK-* adversaries (and MAL-* adversaries are even more powerful) are so powerful that those can just totally obliterate TLS security (just use the private key to decrypt the key exchange). Any security model involving adversaries that can trivially break the protocol is incoherent.\n",
          "createdAt": "2025-11-04T09:00:44Z",
          "updatedAt": "2025-11-04T09:02:06Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "> > a) The diagram follows the same convention as TLS 1.3 key schedule in RFC8446, where the listed messages represent the transcript hash of those messages, not the raw message bytes.\n> \n> I find this unclear. Searching for \"transcript\" gives no hits, \"hash\" only gives one irrelevant one.\n\nPlease look into the figure 5 in https://datatracker.ietf.org/doc/draft-ietf-tls-rfc8446bis/, it uses Derive-Secret which internally generates transcript of the messages :\n\n       Derive-Secret(Secret, Label, Messages) =\n            HKDF-Expand-Label(Secret, Label,\n                              Transcript-Hash(Messages), Hash.length)\n\n> \n> > b) please clarify why MAL-* models are not applicable to TLS ?\n> \n> Even LEAK-* adversaries (and MAL-* adversaries are even more powerful) are so powerful that those can just totally obliterate TLS security (just use the private key to decrypt the key exchange). Any security model involving adversaries that can trivially break the protocol is incoherent.\n\nOkay, I will remove the line. \n",
          "createdAt": "2025-11-04T10:12:29Z",
          "updatedAt": "2025-11-04T10:12:29Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Remove MAL* in https://github.com/tlswg/tls-key-update/pull/82. ",
          "createdAt": "2025-11-05T06:23:35Z",
          "updatedAt": "2025-11-05T06:23:35Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOMJPqLM7V2eI9",
      "title": "Terminology change for long term keys",
      "url": "https://github.com/tlswg/tls-key-update/issues/84",
      "state": "CLOSED",
      "author": "stfries",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "stfries"
      ],
      "labels": [],
      "body": "During IETF 124 there was a discussion on the terminology of the long term key, which may be confused with certificates also often named long term credentials or keys. \nWe should either explain the term or better using the term TLS main secret. I would propose to use latter as it better aligns with the terminology from TLS 1.3 (RFC 8446bis).\nWe should also note that the TLS main secret and traffic keys are ephemeral values. Also, the main secret should be deleted once the necessary traffic secrets have been derived, as it is no longer needed.  \n\n",
      "createdAt": "2025-11-04T18:51:12Z",
      "updatedAt": "2025-11-06T12:00:11Z",
      "closedAt": "2025-11-06T12:00:11Z",
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "see related [PR](https://github.com/tlswg/tls-key-update/pull/85/commits/384a197c216e9f70b697dcced5347149503651b4) ",
          "createdAt": "2025-11-05T10:16:24Z",
          "updatedAt": "2025-11-05T10:16:24Z"
        },
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "PR closed",
          "createdAt": "2025-11-06T12:00:11Z",
          "updatedAt": "2025-11-06T12:00:11Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOMJPqLM7XO4nD",
      "title": "Update to PCS",
      "url": "https://github.com/tlswg/tls-key-update/issues/88",
      "state": "CLOSED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This seems woefully under-specified. How exactly is the hash incorporated into the calculation? Where in \"authenticator transcript\" is the hash added? Is it wrapped in message_hash type (like the hashed Client Hello from base TLS 1.3)? Are all EKU exchanges included, or is just the most recent one? What about the finished transcript (note RFC9261 is designed so that the hash can be multi-tapped).\n\nMore serious problem is that there is nothing to prevent EKU from racing with exporter authenticator, leading to receiver using different EKU transcript from sender. Which causes EA that should work being rejected (which might cause fatal application error).\n\nHowever, again it is possible to do something clever: Instead of using the RFC9261 construction with normal TLS exporter interface for exported authenticators, use RFC9261 construction with epoch-aware TLS exporter, and send the correct epoch along with the exported authenticator.This requires application protocol changes, but those seem necessary anyway.\n",
      "createdAt": "2025-11-11T07:09:07Z",
      "updatedAt": "2025-11-13T07:01:19Z",
      "closedAt": "2025-11-13T07:01:19Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed issue in https://github.com/tlswg/tls-key-update/pull/89 ",
          "createdAt": "2025-11-13T07:01:19Z",
          "updatedAt": "2025-11-13T07:01:19Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDOMJPqLM7XUDiA",
      "title": "Exporter_secret probably should != exporter_secret_0",
      "url": "https://github.com/tlswg/tls-key-update/issues/90",
      "state": "CLOSED",
      "author": "ilaril",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, `exporter_secret_0` seems to equal `exporter_secret`. This requires an implementation to keep the exporter keys for the first epoch for the entire connection duration \u2014 as application might use the TLS 1.3 exporter interface.\n\nThis degrades security, as while EKU-aware applications use `exporter_secret` only for authentication \u2014 which can not be retroactively broken \u2014 those use `exporter_secret_0` for the initial encryption keys. Thus, compromise after the first epoch has ended can still compromise the data in the first epoch.\n\nThis can be fixed by making `exporter_secret_<N>` use a different label from `exporter_secret` \u2014 e.g., \"exp epoch\".",
      "createdAt": "2025-11-11T13:36:52Z",
      "updatedAt": "2026-01-14T05:04:24Z",
      "closedAt": "2026-01-14T05:04:24Z",
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft uses exporter_secret_{N+1}. exporter_secret_{N+1} is not derived from the TLS 1.3 exporter_secret or any prior exporter_secret_{N}. Each exporter_secret_{N+1} is derived from the ephermeal ECDH established during the Extended Key Update. I don't see a need to use a different label to derive \"exporter_secret_{N+1}\".\n\n",
          "createdAt": "2025-11-13T08:02:07Z",
          "updatedAt": "2025-11-13T08:02:07Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "What secret does Epoch-aware TLS Exporter use if application specifies epoch=0 (presumably after server finished, but before the first EKU)?\n\n- Making that an error runs into the security issue.\n- Using exporter_secret_0 == exporter_secret runs into the security issue.\n- exporter_secret_1 is not available, so can not be used.\n\nThe only thing that would work and avoid the security issue is using exporter_secret_0 != exporter_secret.",
          "createdAt": "2025-11-13T14:25:03Z",
          "updatedAt": "2025-11-13T14:25:03Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @ilaril  for the explanation. I propose to add the following text:\n\nTLS specifies a single exporter_secret derived from the main secret. This value is static for the entire duration of a TLS session and is not updated by EKU. The new exporter interface defined in this document derives a fresh exporter secret whenever new application traffic keys are established through the EKU mechanism. A core design goal of this interface is that compromise of exporter-secret material at a later point in time MUST NOT enable an attacker to recover exporter outputs that were produced earlier in the connection.  If the initial exporter secret for this interface were equal to the TLS exporter_secret, this property would be violated: compromise of the TLS exporter_secret at any time during the connection would allow an attacker to retroactively recompute all exporter outputs that depend on it.\n\nTherefore, the initial exporter secret used by the interface defined in this document, i.e., the exporter output available prior to the first EKU MUST be distinct from the TLS  exporter_secret. This separation ensures that compromise of the TLS exporter interface does not compromise outputs from this new exporter interface.\n\n~~~\nexporter_secret_0 = Derive-Secret(Main Secret, \"pre-update exporter\", ClientHello...server Finished)\n~~~",
          "createdAt": "2025-11-14T12:38:12Z",
          "updatedAt": "2025-11-14T12:38:12Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue is addressed in https://github.com/tlswg/tls-key-update/pull/92.",
          "createdAt": "2026-01-14T05:04:24Z",
          "updatedAt": "2026-01-14T05:04:24Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOMJPqLM7jSimq",
      "title": "Stronger PCS",
      "url": "https://github.com/tlswg/tls-key-update/issues/94",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This may have been discussed/rejected at the TLS WG, if so let me know.\n\nThe document mentions an attack on PCS where an attacker breaches one of the peers and then acts as a MITM. And this can be mitigated by some post-handshake mechanisms.\n\nHowever, I think there's inherent value to EKU even in \"normal\" TLS environments where none of these mechanisms are deployed.\n\nI believe if you added a CertificateVerify-like message coming from the server in message 2 (`EKU(key_update_response`), this would address 99% of the normal TLS use cases, where the server is authenticated by a cert, prevent the MITM attack and provide full PCS.\n\nAnd yes, this does require a formal proof.",
      "createdAt": "2026-01-14T13:47:54Z",
      "updatedAt": "2026-01-18T14:36:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "While I see security benefits of it, API logistics might be too costly for some TLS implementations. For instance, one may need to maintain the private key of the certificate that was used during initial handshake. Also this will add complexity to the EKU spec that is already well overdue.\nOn top of that, in absence of mTLS this would work only for the server side.\n\nIt feels to me that a variant of [draft-rosomakho-tls-cert-update-01](https://datatracker.ietf.org/doc/draft-rosomakho-tls-cert-update/) might be a better solution: a party could re-authenticate with the same certificate after EKU.",
          "createdAt": "2026-01-17T07:28:31Z",
          "updatedAt": "2026-01-17T07:56:35Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "> While I see security benefits of it, API logistics might be too costly for some TLS implementations. For instance, one may need to maintain the private key of the certificate that was used during initial handshake.\n\nThe private key is long-lived, so it stays there basically forever. What needs to be maintained is a *handle* to the private key, but that's essentially the identity of the TLS peer so it's an essential detail of the connection. (To be clear, what I suggest only makes sense if the private key is in an HSM, but that's common for high-risk servers.)\n\n> Also this will add complexity to the EKU spec that is already well overdue.\n\nTrue, but sadly, the EKU spec does not provide its advertised security. Specifically its main goal is PCS, and it does not provide PCS in this scenario which falls clearly within the normal Internet threat model.\n\n> On top of that, in absence of mTLS this would work only for the server side.\n\nIf you mean that the scope is incomplete, I agree. If you mean it will not work, I disagree: the client will issue an alert and abort the connection.\n\n> \n> It feels to me that a variant of [draft-rosomakho-tls-cert-update-01](https://datatracker.ietf.org/doc/draft-rosomakho-tls-cert-update/) might be a better solution: a party could re-authenticate with the same certificate after EKU.\n\nMaybe it's time I wrote a blog about the way we are mixing in-handshake and post-handshake in the ongoing IETF work on TLS. We have millions of application developers who expect a certain level of security from TLS, and when they configure EKU (a TLS-level mechanism), they also expect PCS without resorting to application-level mechanisms. It's our job to provide that.",
          "createdAt": "2026-01-18T08:59:41Z",
          "updatedAt": "2026-01-18T08:59:41Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "First of all, I think this is an important topic that we need to discuss in a wider group - perhaps at the next IETF meeting. Thank you for bringing this up.\n\nSecondly, I think key property of EKU is to bring TLS 1.3 PCS properties on par with other modern secure protocols in their typical deployments - Wireguard, SSHv2 perform periodic re-keying but do not re-authenticate. IKEv2 has an option to re-authenticate but I have not seen that used in the wild.\n\nAs of private key for certificates - letsencrypt recently made IP address based certificates with 6 day validity. Normally fresh certificate replaces a private key as well.\n\nI wonder if we should consider an additional mechanism that would work for both parties in all cases - mTLS, traditional server only certificate based authentication or PSK. For example, something along the lines of DPoP from Oauth land, where both parties produce a key pair at the handshake time and re-validate possession of the same private key after EKU.\n\nIn any case, I would strongly prefer that such mechanism would be an addon on top of EKU described in current draft. After all, the current design with message subtype allows future extensions.\n\nAs of certificate update draft I mentioned previously - it provides Certificate Update as a part of TLS instead of relying on each application to implement exported authenticators on their layer.",
          "createdAt": "2026-01-18T10:51:25Z",
          "updatedAt": "2026-01-18T10:51:25Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "Yep, let's discuss it with the larger group.\n\n> I wonder if we should consider an additional mechanism that would work for both parties in all cases - mTLS, traditional server only certificate based authentication or PSK. For example, something along the lines of DPoP from Oauth land, where both parties produce a key pair at the handshake time and re-validate possession of the same private key after EKU.\n\nThe problem with this idea (and why I think this needs to be done with the long-term private key) is that everything generated within the TLS session, such as all the secrets that are being derived by the TLS key schedule, is known to an attacker that breaches the server temporarily. The design constraints for EKU are really really narrow!\n\n> In any case, I would strongly prefer that such mechanism would be an addon on top of EKU described in current draft. After all, the current design with message subtype allows future extensions.\n\nPerhaps this is a good way forward, but again: the current proposal does not meet its purported security goals IMHO.",
          "createdAt": "2026-01-18T12:47:50Z",
          "updatedAt": "2026-01-18T12:47:50Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "For this to deliver expected security properties, private key would need to reside on a TPM and not be exposed in case of a memory dump. I don't see the need to generate a key pair for each TLS session. One per endpoint (with some reasonable rotation) should be enough.",
          "createdAt": "2026-01-18T13:18:41Z",
          "updatedAt": "2026-01-18T13:18:41Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "> For this to deliver expected security properties, private key would need to reside on a TPM and not be exposed in case of a memory dump. I don't see the need to generate a key pair for each TLS session. One per endpoint (with some reasonable rotation) should be enough.\n\nJust to clarify: each client would need _many_ private keys - one for each endpoint that the client is communicating with. Otherwise you'd have privacy issues, with the keypair acting as an identifier.",
          "createdAt": "2026-01-18T14:36:30Z",
          "updatedAt": "2026-01-18T14:36:30Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOMJPqLM50eFLu",
      "title": "Added Yaroslav",
      "url": "https://github.com/tlswg/tls-key-update/pull/4",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-04T18:23:11Z",
      "updatedAt": "2024-07-06T08:16:10Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "b39ead032117c5749ba065e717e2f17e815b47d5",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-1",
      "headRefOid": "2104530cfa428aa084b4d3f0b8169db49a02d04d",
      "closedAt": "2024-07-06T08:16:10Z",
      "mergedAt": "2024-07-06T08:16:10Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "960171f5bccb5e52080caa667c7b272088b6953c"
      },
      "comments": [
        {
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine with me. ",
          "createdAt": "2024-07-04T18:31:35Z",
          "updatedAt": "2024-07-04T18:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6AtacT",
          "commit": {
            "abbreviatedOid": "2104530"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-04T18:33:19Z",
          "updatedAt": "2024-07-04T18:33:19Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Fine from my point of view ",
              "createdAt": "2024-07-04T18:33:19Z",
              "updatedAt": "2024-07-04T18:33:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6AtahN",
          "commit": {
            "abbreviatedOid": "2104530"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Fine from my point of view",
          "createdAt": "2024-07-04T18:33:42Z",
          "updatedAt": "2024-07-04T18:33:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMJPqLM50lY6Y",
      "title": "Address pending issues",
      "url": "https://github.com/tlswg/tls-key-update/pull/5",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "updated draft to address https://github.com/hannestschofenig/tls-key-update/issues/2 and alert to handle or too many extended key update requests.",
      "createdAt": "2024-07-06T08:51:38Z",
      "updatedAt": "2024-07-06T14:17:01Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "960171f5bccb5e52080caa667c7b272088b6953c",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-1",
      "headRefOid": "1dd4bd0b0991fa0ecc0bfd9fce6ed9c429b47d32",
      "closedAt": "2024-07-06T14:16:58Z",
      "mergedAt": "2024-07-06T14:16:58Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "38482e0dba20f1d25a12c6d810722ffef5cb3836"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Tiru, for the PR!",
          "createdAt": "2024-07-06T14:16:55Z",
          "updatedAt": "2024-07-06T14:16:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOMJPqLM50mzaf",
      "title": "Update to \"Updating Traffic Secrets Section\"",
      "url": "https://github.com/tlswg/tls-key-update/pull/6",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-07T06:40:35Z",
      "updatedAt": "2024-07-08T13:48:30Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "1b157281482bb37047d91538458412e311c2ac6f",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-1",
      "headRefOid": "cba9433cbc57996a16493de714b18614027d3984",
      "closedAt": "2024-07-08T13:48:27Z",
      "mergedAt": "2024-07-08T13:48:27Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "3f72764465d7c54830de0f119b42e2d5df4e1b1f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOMJPqLM59vUBy",
      "title": "Added status for soft rejection of the request",
      "url": "https://github.com/tlswg/tls-key-update/pull/7",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed, here is my suggestion for soft rejection of extended key update request.\r\n\r\nIt should be up to initiator to terminate the connection if it is not happy with the rejection instead of taking the risk of getting connection terminated by responder if it does not want to proceed.",
      "createdAt": "2024-10-06T20:09:35Z",
      "updatedAt": "2024-10-10T05:36:33Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "3f72764465d7c54830de0f119b42e2d5df4e1b1f",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "main",
      "headRefOid": "d76ae0cc73a85acbf70afa68d36c08539fefcd24",
      "closedAt": "2024-10-10T05:36:33Z",
      "mergedAt": "2024-10-10T05:36:33Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "a0b969d09eb9cfb77d98efd475bb04c8a6260c2e"
      },
      "comments": [
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "As suggested, updated with adding delay specification for retry status code and removed unnecessary alert reference.",
          "createdAt": "2024-10-07T21:34:04Z",
          "updatedAt": "2024-10-07T21:34:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6MLec2",
          "commit": {
            "abbreviatedOid": "9c920ba"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T12:33:46Z",
          "updatedAt": "2024-10-07T12:45:48Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I think a fatal alert means both the peers will have to immediately close the connection (see https://www.ietf.org/archive/id/draft-ietf-tls-rfc8446bis-11.html#error-alerts). ",
              "createdAt": "2024-10-07T12:33:46Z",
              "updatedAt": "2024-10-07T12:45:48Z"
            },
            {
              "originalPosition": 49,
              "body": "What would be the delay time? It would be helpful if the responder could indicate the time after which the initiator can retry the extended key update.",
              "createdAt": "2024-10-07T12:37:55Z",
              "updatedAt": "2024-10-07T12:45:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6MRr4n",
          "commit": {
            "abbreviatedOid": "5463696"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T05:42:46Z",
          "updatedAt": "2024-10-08T05:42:51Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I suggest to replace \"should terminate\" with \"MUST terminate\". Rest of the changes look good to me. ",
              "createdAt": "2024-10-08T05:42:46Z",
              "updatedAt": "2024-10-08T05:42:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6Mh21m",
          "commit": {
            "abbreviatedOid": "5463696"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-09T16:43:35Z",
          "updatedAt": "2024-10-09T16:43:35Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Good suggestions. Updated accordingly.",
              "createdAt": "2024-10-09T16:43:35Z",
              "updatedAt": "2024-10-09T16:43:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOMJPqLM59vWIZ",
      "title": "Added relevant SSLKEYLOGFILE labels",
      "url": "https://github.com/tlswg/tls-key-update/pull/8",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In line with the SSLKEYLOGFILE spec.\r\nConveniently existing initial secret labels are already called \"CLIENT_TRAFFIC_SECRET_0\" and \"SERVER_TRAFFIC_SECRET_0\", so continuing numbering scheme seems to be no-brainer.",
      "createdAt": "2024-10-06T20:37:55Z",
      "updatedAt": "2024-10-10T05:36:20Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "3f72764465d7c54830de0f119b42e2d5df4e1b1f",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "sslkeylog",
      "headRefOid": "434b79f7fc228af731c816cd457af50fecf3f6ab",
      "closedAt": "2024-10-10T05:36:20Z",
      "mergedAt": "2024-10-10T05:36:20Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "09e31f195ccb1f4ee5de1f92901af5b897dace0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6MLa79",
          "commit": {
            "abbreviatedOid": "e2329a5"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T12:27:33Z",
          "updatedAt": "2024-10-07T12:27:33Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "We may want to add the following text to this section : \r\nNote that even with knowledge of '_TRAFFIC_SECRET_N+1', none of the subsequent application data traffic secrets generated using extended key update can be derived.",
              "createdAt": "2024-10-07T12:27:33Z",
              "updatedAt": "2024-10-07T12:27:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6MLbPP",
          "commit": {
            "abbreviatedOid": "e2329a5"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Rest of the changes look good to me. ",
          "createdAt": "2024-10-07T12:28:05Z",
          "updatedAt": "2024-10-07T12:28:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM6MP0_c",
          "commit": {
            "abbreviatedOid": "e2329a5"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-07T21:22:45Z",
          "updatedAt": "2024-10-07T21:22:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I'm not sure if I fully understand this suggestion. `CLIENT_TRAFFIC_SECRET_N+1` and `SERVER_TRAFFIC_SECRET_N+1` would provide secrets to decrypt application data traffic right after the Extended Key Update.\r\nAre you referring to the fact that new set of SSLKEYLOG entries needs to be generated for each Extended Key Update?",
              "createdAt": "2024-10-07T21:22:45Z",
              "updatedAt": "2024-10-07T21:22:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6MRtWG",
          "commit": {
            "abbreviatedOid": "e2329a5"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-08T05:45:04Z",
          "updatedAt": "2024-10-08T05:45:04Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yes, I am referring that a new set of SSLKEYLOG entries need to be generated for each Extended Key Update.",
              "createdAt": "2024-10-08T05:45:04Z",
              "updatedAt": "2024-10-08T05:45:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6Mh2OL",
          "commit": {
            "abbreviatedOid": "e2329a5"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-09T16:42:14Z",
          "updatedAt": "2024-10-09T16:42:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Addressed the suggestion with following wording:\r\n\r\nNote that each successful Extended Key Update invalidates all previous SSLKEYLOGFILE secrets including\r\npast iterations of `CLIENT_TRAFFIC_SECRET_` and `SERVER_TRAFFIC_SECRET_`.",
              "createdAt": "2024-10-09T16:42:14Z",
              "updatedAt": "2024-10-09T16:42:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6Mm8s3",
          "commit": {
            "abbreviatedOid": "434b79f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Update looks good to me. ",
          "createdAt": "2024-10-10T05:35:46Z",
          "updatedAt": "2024-10-10T05:35:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOMJPqLM5-VOFm",
      "title": "Update draft-ietf-tls-extended-key-update.md",
      "url": "https://github.com/tlswg/tls-key-update/pull/9",
      "state": "MERGED",
      "author": "stfries",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- replaced \"key update \"by \"update of master keys\" in the introduction when referring to the negotiated keys with session renegotiation in TLS 1.2\r\n- addressed some smaller editorial nits",
      "createdAt": "2024-10-11T11:23:38Z",
      "updatedAt": "2024-10-15T13:47:40Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f106aa116e27878e34a7a0c78b3cc1dd611ad68f",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "stfries-patch-1",
      "headRefOid": "d00a088095aaea83f6ad95283644afcca7e51977",
      "closedAt": "2024-10-15T13:47:27Z",
      "mergedAt": "2024-10-15T13:47:27Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "81c0d5106077e1479d21c447a50cb2437db5f8c7"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Steffen.",
          "createdAt": "2024-10-15T13:47:40Z",
          "updatedAt": "2024-10-15T13:47:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6NOlZ_",
          "commit": {
            "abbreviatedOid": "4d408e4"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T13:47:05Z",
          "updatedAt": "2024-10-15T13:47:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nGerman BSI, and French ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward\r\n```",
              "createdAt": "2024-10-15T13:47:06Z",
              "updatedAt": "2024-10-15T13:47:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOMJPqLM5_GXUa",
      "title": "Update to Exporter",
      "url": "https://github.com/tlswg/tls-key-update/pull/10",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-18T12:42:45Z",
      "updatedAt": "2024-10-20T06:34:48Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "81c0d5106077e1479d21c447a50cb2437db5f8c7",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-1",
      "headRefOid": "d94e723f60d0e1582b21b9eb80fd826598fa5170",
      "closedAt": "2024-10-20T06:34:48Z",
      "mergedAt": "2024-10-20T06:34:48Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "25d7fa4ba82adf0adcb7bdb3b63f1cadefd63a65"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6N1C6e",
          "commit": {
            "abbreviatedOid": "d94e723"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2024-10-19T14:14:50Z",
          "updatedAt": "2024-10-19T14:14:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOMJPqLM5_OuI9",
      "title": "Updated IANA considerations to reflect new alert name",
      "url": "https://github.com/tlswg/tls-key-update/pull/11",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-20T15:49:37Z",
      "updatedAt": "2024-10-21T21:05:00Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "25d7fa4ba82adf0adcb7bdb3b63f1cadefd63a65",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "main",
      "headRefOid": "6196462e769226acada11001320e7fe64865b3c6",
      "closedAt": "2024-10-21T21:05:00Z",
      "mergedAt": "2024-10-21T21:05:00Z",
      "mergedBy": "yaroslavros",
      "mergeCommit": {
        "oid": "ade53c93e786f2005544ca525ae72ff97a213ba7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMJPqLM6LnBtV",
      "title": "Updated Abstract",
      "url": "https://github.com/tlswg/tls-key-update/pull/12",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on feedback from Matthijs van Duin I have updated the abstract to better describe the goal of this specification.",
      "createdAt": "2025-02-18T14:44:36Z",
      "updatedAt": "2025-02-26T14:44:55Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "4bbdbf85177394e500954d112bf66babc7380b04",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-2",
      "headRefOid": "a243c2e856d80ccecdc75411b8aa6edc90115cf1",
      "closedAt": "2025-02-26T14:44:51Z",
      "mergedAt": "2025-02-26T14:44:51Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "2f36d62cce91ed18b5a169f8eb51f1f95ad0e2f5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6ctrPk",
          "commit": {
            "abbreviatedOid": "48402d2"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Rest of changes look good. ",
          "createdAt": "2025-02-20T09:30:51Z",
          "updatedAt": "2025-02-20T09:31:04Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I suggest to replace \"Diffie-Hellman\" with \"ephemeral key exchange\"",
              "createdAt": "2025-02-20T09:30:51Z",
              "updatedAt": "2025-02-20T09:31:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6cxZfZ",
          "commit": {
            "abbreviatedOid": "48402d2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-20T15:11:06Z",
          "updatedAt": "2025-02-20T15:11:07Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nby utilizing an ephemeral key exchange during the initial handshake. Forward\r\n```",
              "createdAt": "2025-02-20T15:11:07Z",
              "updatedAt": "2025-02-20T15:11:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6czxKo",
          "commit": {
            "abbreviatedOid": "bcda715"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Changes look okay for me. I only added smaller proposal to enhance the statement regarding cryptographic parameter negotiation. \r\nI know, we do not provide that certificate update option in the ExtendedKeyUpdate, but I thought it would be good to point to that capability in TLS 1.2",
          "createdAt": "2025-02-20T18:33:12Z",
          "updatedAt": "2025-02-20T18:59:08Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Maybe to add, session renegotiation did not only allow to establish new cryptographic parameter for the sesssion, it also allowed to utilized an updated long term credential (certificate). This adresses cases, were the initially used long term credential may have reached the validity end or may have been revoked in the meantime. \r\n\r\nProposal to change the sentence to:\r\nEarlier versions of TLS supported session renegotiation, a mechanism that allowed peers to\r\nestablish new cryptographic parameters within an existing session including the potential update of the initially utilized long term keys (certificates) with renewed credentials. ",
              "createdAt": "2025-02-20T18:33:12Z",
              "updatedAt": "2025-02-20T18:43:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOMJPqLM6L6oVt",
      "title": "Update archive.yml",
      "url": "https://github.com/tlswg/tls-key-update/pull/13",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-20T15:18:33Z",
      "updatedAt": "2025-02-20T15:19:03Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "4bbdbf85177394e500954d112bf66babc7380b04",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-3",
      "headRefOid": "7d6efae315f45871e1814aed36f6e58b65c1fa42",
      "closedAt": "2025-02-20T15:19:02Z",
      "mergedAt": "2025-02-20T15:19:02Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "1aacb292128df1676889ee6f6d829e258a05bc0f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOMJPqLM6L8eFF",
      "title": "Review by Rifaat",
      "url": "https://github.com/tlswg/tls-key-update/pull/14",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-20T19:01:43Z",
      "updatedAt": "2025-02-26T14:45:16Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "2f36d62cce91ed18b5a169f8eb51f1f95ad0e2f5",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-4",
      "headRefOid": "104b33d7a8a9d4baf50a9360dc97f8f32827a345",
      "closedAt": "2025-02-26T14:45:12Z",
      "mergedAt": "2025-02-26T14:45:12Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "8e3ee9cd8dec14fd93d98b07cae671f749706583"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6c5bnD",
          "commit": {
            "abbreviatedOid": "104b33d"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-21T08:06:31Z",
          "updatedAt": "2025-02-21T08:06:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOMJPqLM6MwwMH",
      "title": "Fix diagram",
      "url": "https://github.com/tlswg/tls-key-update/pull/15",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on feedback from Rifaat",
      "createdAt": "2025-02-27T08:45:38Z",
      "updatedAt": "2025-02-27T09:52:53Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "8e3ee9cd8dec14fd93d98b07cae671f749706583",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-2",
      "headRefOid": "4378a7c64317944aec6e979b73b4b0ab5f3e46e1",
      "closedAt": "2025-02-27T09:52:48Z",
      "mergedAt": "2025-02-27T09:52:48Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "f033ef6b8ea29b9a1893e81a8ddb5768ce81132a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOMJPqLM6OwAvi",
      "title": "PQC Typo",
      "url": "https://github.com/tlswg/tls-key-update/pull/16",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-15T03:07:15Z",
      "updatedAt": "2025-04-18T11:51:49Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f033ef6b8ea29b9a1893e81a8ddb5768ce81132a",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-2",
      "headRefOid": "b67fdc17806a222ac7534ce42d2f5a5a6db58361",
      "closedAt": "2025-04-18T11:51:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOMJPqLM6OzjWj",
      "title": "Updated description of the key update",
      "url": "https://github.com/tlswg/tls-key-update/pull/17",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-16T03:48:41Z",
      "updatedAt": "2025-04-27T07:38:43Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f033ef6b8ea29b9a1893e81a8ddb5768ce81132a",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-4",
      "headRefOid": "0141d9a28aaf647c7b961534f2d8ad9e1d0f3fae",
      "closedAt": "2025-04-27T07:38:43Z",
      "mergedAt": "2025-04-27T07:38:43Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "71f03272263f4ea3db8f863867803f5863b9537a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6mvlaC",
          "commit": {
            "abbreviatedOid": "0141d9a"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-27T07:38:37Z",
          "updatedAt": "2025-04-27T07:38:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOMJPqLM6O1Ijd",
      "title": "Fix typo for Post Quantum cryptography",
      "url": "https://github.com/tlswg/tls-key-update/pull/18",
      "state": "MERGED",
      "author": "loganaden",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-16T19:44:33Z",
      "updatedAt": "2025-04-18T11:51:21Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f033ef6b8ea29b9a1893e81a8ddb5768ce81132a",
      "headRepository": "loganaden/tls-key-update",
      "headRefName": "patch-1",
      "headRefOid": "40c2b34c1885df95612bc6fe266183b8ff40d83b",
      "closedAt": "2025-04-18T11:51:20Z",
      "mergedAt": "2025-04-18T11:51:20Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "4c7c08faa022a9dbd696850969cd9af57c3fd458"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch!",
          "createdAt": "2025-04-18T11:51:16Z",
          "updatedAt": "2025-04-18T11:51:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOMJPqLM6djXbe",
      "title": "New Abstract",
      "url": "https://github.com/tlswg/tls-key-update/pull/28",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T12:22:57Z",
      "updatedAt": "2025-07-05T14:33:52Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "47fabe0e58146b18e303ece4ffddc357327ead0f",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-5",
      "headRefOid": "044c16c8fb1b35a350e989a4e08e80b6f50ced8a",
      "closedAt": "2025-07-05T14:33:49Z",
      "mergedAt": "2025-07-05T14:33:49Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "cffaaefb88eadfd1a50f0e3c7e9f14a624f7dc93"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yN9lh",
          "commit": {
            "abbreviatedOid": "044c16c"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-05T12:50:21Z",
          "updatedAt": "2025-07-05T12:50:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOMJPqLM6djcB1",
      "title": "Updated \"Introduction\" and removed \" Key Exfiltration and Forward Sec\u2026",
      "url": "https://github.com/tlswg/tls-key-update/pull/29",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026recy\" Section",
      "createdAt": "2025-07-05T12:47:52Z",
      "updatedAt": "2025-07-05T14:34:31Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "47fabe0e58146b18e303ece4ffddc357327ead0f",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "7dd407d510ac424a1c55dda2dc335e7e42df8b12",
      "closedAt": "2025-07-05T14:34:29Z",
      "mergedAt": "2025-07-05T14:34:29Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "face47eaae1b2f80b048a39ed5ba65cdda9a99a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yN9oI",
          "commit": {
            "abbreviatedOid": "08c0613"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-05T12:50:57Z",
          "updatedAt": "2025-07-05T12:50:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOMJPqLM6dj4hz",
      "title": "Extended Key Update replaces the Standard Key Update",
      "url": "https://github.com/tlswg/tls-key-update/pull/30",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T14:39:30Z",
      "updatedAt": "2025-07-07T08:42:27Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "face47eaae1b2f80b048a39ed5ba65cdda9a99a2",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-5",
      "headRefOid": "790fa2fc915fd36e3085594a798edb04934aad46",
      "closedAt": "2025-07-07T08:42:23Z",
      "mergedAt": "2025-07-07T08:42:23Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "4749c1934b868a5c2665635552e17c97ae0b44dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yTdpZ",
          "commit": {
            "abbreviatedOid": "790fa2f"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-06T15:46:32Z",
          "updatedAt": "2025-07-06T15:46:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOMJPqLM6dj_yn",
      "title": "Correcting the Message Registration",
      "url": "https://github.com/tlswg/tls-key-update/pull/31",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and clarifying text throughout the draft.",
      "createdAt": "2025-07-05T15:12:42Z",
      "updatedAt": "2025-07-07T08:43:56Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "4749c1934b868a5c2665635552e17c97ae0b44dd",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "6a9502c0005a89cf1fd596d46c850c36bae56f73",
      "closedAt": "2025-07-07T08:43:53Z",
      "mergedAt": "2025-07-07T08:43:53Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "996ce0066c1c22ea0035dc5b95b1f5ea72f747a9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yTdhI",
          "commit": {
            "abbreviatedOid": "b8b8670"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-06T15:45:19Z",
          "updatedAt": "2025-07-06T15:45:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOMJPqLM6dkIsL",
      "title": "Updated text in \"SSLKEYLOGFILE Update\" and \"Exporter\"",
      "url": "https://github.com/tlswg/tls-key-update/pull/32",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T15:52:27Z",
      "updatedAt": "2025-07-07T08:44:08Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "face47eaae1b2f80b048a39ed5ba65cdda9a99a2",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-7",
      "headRefOid": "af50ed66cc0ed1465714478aa90bf06eaeccb27d",
      "closedAt": "2025-07-07T08:44:05Z",
      "mergedAt": "2025-07-07T08:44:05Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "764d5f73f110bc73004920e16548a02219135028"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yTddv",
          "commit": {
            "abbreviatedOid": "af50ed6"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-06T15:44:30Z",
          "updatedAt": "2025-07-06T15:44:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOMJPqLM6dkYyj",
      "title": "Update to the Key Derivation",
      "url": "https://github.com/tlswg/tls-key-update/pull/33",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T16:39:49Z",
      "updatedAt": "2025-07-07T08:48:47Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "c01c0490e6ac241a6b9a6a7fea0e6dc75d76a0ac",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-8",
      "headRefOid": "2b56a22da2a96914ac605e400ae983b3284fc2a8",
      "closedAt": "2025-07-07T08:48:43Z",
      "mergedAt": "2025-07-07T08:48:43Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "5eae8b793e84297c685ec5904534453263d6ebe6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yTdVj",
          "commit": {
            "abbreviatedOid": "c18dc90"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-06T15:43:23Z",
          "updatedAt": "2025-07-06T15:43:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOMJPqLM6dpTRV",
      "title": "Adding Joe Birr-Pixton to Acknowledgments Section",
      "url": "https://github.com/tlswg/tls-key-update/pull/34",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-06T17:24:59Z",
      "updatedAt": "2025-07-07T08:44:21Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "face47eaae1b2f80b048a39ed5ba65cdda9a99a2",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-9",
      "headRefOid": "7334dff4fbc2e6e73ad620a3bcabfe1642346c9a",
      "closedAt": "2025-07-07T08:44:19Z",
      "mergedAt": "2025-07-07T08:44:18Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "c01c0490e6ac241a6b9a6a7fea0e6dc75d76a0ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOMJPqLM6dtdZk",
      "title": "Legend for Figure",
      "url": "https://github.com/tlswg/tls-key-update/pull/35",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T08:41:08Z",
      "updatedAt": "2025-07-07T13:11:45Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "5eae8b793e84297c685ec5904534453263d6ebe6",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-10",
      "headRefOid": "ac706798ce8515842afd226e5f138c2bda6f572e",
      "closedAt": "2025-07-07T13:11:43Z",
      "mergedAt": "2025-07-07T13:11:42Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "599e47d445bcbcc77b09fbe5a482705fdb2be04c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOMJPqLM6dxiuL",
      "title": "Updated Post-Quantum Cryptography Considerations Section",
      "url": "https://github.com/tlswg/tls-key-update/pull/36",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T14:30:46Z",
      "updatedAt": "2025-07-19T08:20:50Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "599e47d445bcbcc77b09fbe5a482705fdb2be04c",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-5",
      "headRefOid": "08e80b2c3ec98ce7cf8040bd321498d1c5147c7d",
      "closedAt": "2025-07-19T08:20:50Z",
      "mergedAt": "2025-07-19T08:20:50Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "d151fff133866a40725039dd77a53f6b92cb90e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6yescJ",
          "commit": {
            "abbreviatedOid": "bfb4b4d"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T15:41:31Z",
          "updatedAt": "2025-07-07T15:41:35Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "The above line is not correct, the ietf-tls-mlkem draft registers only ML-KEM and its variants. we may want to say: \r\nThe specification in {{I-D.ietf-tls-mlkem}} registers the lattice-based ML-KEM algorithm and its variants, such as ML-KEM-512, ML-KEM-768 and ML-KEM-1024. The KEM encapsulation key or KEM ciphertext is represented as a 'KeyShareEntry' field. This same\r\napproach is reused during the Extended Key Update, when new key shares are exchanged.",
              "createdAt": "2025-07-07T15:41:31Z",
              "updatedAt": "2025-07-07T15:41:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM60zVcZ",
          "commit": {
            "abbreviatedOid": "bfb4b4d"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-18T12:20:44Z",
          "updatedAt": "2025-07-18T12:20:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Thanks, Tiru. I incoporated your wording.",
              "createdAt": "2025-07-18T12:20:44Z",
              "updatedAt": "2025-07-18T12:20:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM606sxx",
          "commit": {
            "abbreviatedOid": "08e80b2"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-19T08:20:40Z",
          "updatedAt": "2025-07-19T08:20:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOMJPqLM6eDSrX",
      "title": "Update to Key Update Procedure",
      "url": "https://github.com/tlswg/tls-key-update/pull/37",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-09T05:18:23Z",
      "updatedAt": "2025-07-19T08:19:42Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "599e47d445bcbcc77b09fbe5a482705fdb2be04c",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-2",
      "headRefOid": "761f46c4ec2f42691863ea7a08dabb9b26e4fac4",
      "closedAt": "2025-07-19T08:19:41Z",
      "mergedAt": "2025-07-19T08:19:41Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "afafc6fa3bd3a8f6f97446d74c7496c9b7b09aa4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM60ymB-",
          "commit": {
            "abbreviatedOid": "dc91659"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-18T11:11:46Z",
          "updatedAt": "2025-07-18T11:11:47Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThis process is repeated for each additional key update procedure.\r\n```",
              "createdAt": "2025-07-18T11:11:47Z",
              "updatedAt": "2025-07-18T11:11:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOMJPqLM6fzA7O",
      "title": "Update TLS Key Update Procedure",
      "url": "https://github.com/tlswg/tls-key-update/pull/38",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on side discussion at IETF 123",
      "createdAt": "2025-07-21T07:38:55Z",
      "updatedAt": "2025-08-19T09:16:06Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "d151fff133866a40725039dd77a53f6b92cb90e6",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "5fa6d2b568e4a46edb96d732da2cff4c03be036c",
      "closedAt": "2025-08-19T09:16:02Z",
      "mergedAt": "2025-08-19T09:16:02Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "f13a5f08f867b6be656b3467be840ecb31b6e482"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM61CLF1",
          "commit": {
            "abbreviatedOid": "5fa6d2b"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T09:30:23Z",
          "updatedAt": "2025-07-21T09:30:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM61DifC",
          "commit": {
            "abbreviatedOid": "5fa6d2b"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-21T11:12:40Z",
          "updatedAt": "2025-07-21T11:12:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOMJPqLM6fz3uB",
      "title": "DTLS 1.3 Considerations",
      "url": "https://github.com/tlswg/tls-key-update/pull/39",
      "state": "CLOSED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on discussion at the IETF 123",
      "createdAt": "2025-07-21T09:12:59Z",
      "updatedAt": "2025-08-29T13:30:52Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "bf25ead02f927b6454fdaa42013ff879860f5fcb",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-7",
      "headRefOid": "c63dd4b7dc288079d9988c90048c0bddf7f7c828",
      "closedAt": "2025-08-29T13:30:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced this PR with a #43 ",
          "createdAt": "2025-08-29T13:30:48Z",
          "updatedAt": "2025-08-29T13:30:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM61CEK1",
          "commit": {
            "abbreviatedOid": "de4a9c7"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T09:23:19Z",
          "updatedAt": "2025-07-21T09:23:19Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I can't parse the last line. ",
              "createdAt": "2025-07-21T09:23:19Z",
              "updatedAt": "2025-07-21T09:23:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DXFM",
          "commit": {
            "abbreviatedOid": "de4a9c7"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T10:59:10Z",
          "updatedAt": "2025-07-21T10:59:10Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Tried to fix the text. Hope it is understandable now...",
              "createdAt": "2025-07-21T10:59:10Z",
              "updatedAt": "2025-07-21T10:59:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DjYt",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T11:13:59Z",
          "updatedAt": "2025-07-21T11:13:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "transmitted",
              "createdAt": "2025-07-21T11:13:59Z",
              "updatedAt": "2025-07-21T11:13:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DmVw",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T11:17:56Z",
          "updatedAt": "2025-07-21T11:17:57Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "This diagram below indicates an [ACK] message. My understanding from yesterday was the the NewKeyUpdate sent by the responder is an implicit acknowledge for the NewKeyUpdate sent by the initiator. Is that understanding correct or incorrect?",
              "createdAt": "2025-07-21T11:17:57Z",
              "updatedAt": "2025-07-21T11:17:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DnZV",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T11:19:10Z",
          "updatedAt": "2025-07-21T11:19:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Are you exchanging ACK and NewKeyUpdate? if yes, why do you describe the sequence of receiving different that the sequence of sending?",
              "createdAt": "2025-07-21T11:19:10Z",
              "updatedAt": "2025-07-21T11:19:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DojO",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T11:20:26Z",
          "updatedAt": "2025-07-21T11:20:26Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I suggest to show in the diagram when send/recv keys are updated.",
              "createdAt": "2025-07-21T11:20:26Z",
              "updatedAt": "2025-07-21T11:20:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61DqNH",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "tuexen",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T11:22:07Z",
          "updatedAt": "2025-07-21T11:22:07Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "This is true. But if we use the procedure described above, requires the use of the older epoch also if no loss and reordering is happening? I think this will happen in normal operation for messages sent during the extended key update...",
              "createdAt": "2025-07-21T11:22:07Z",
              "updatedAt": "2025-07-21T11:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM61Ejmo",
          "commit": {
            "abbreviatedOid": "55d88fe"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-21T12:26:22Z",
          "updatedAt": "2025-07-21T12:26:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nmessages are not transmitted over a reliable transport protocol. As with other\r\n```",
              "createdAt": "2025-07-21T12:26:22Z",
              "updatedAt": "2025-07-21T12:26:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM670Hug",
          "commit": {
            "abbreviatedOid": "5f84be4"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:19:59Z",
          "updatedAt": "2025-08-25T11:20:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "This section needs to be updated to align with https://github.com/tlswg/tls-key-update/pull/40. ",
              "createdAt": "2025-08-25T11:19:59Z",
              "updatedAt": "2025-08-25T11:20:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM68WlJk",
          "commit": {
            "abbreviatedOid": "5f84be4"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-27T14:26:09Z",
          "updatedAt": "2025-08-27T14:26:09Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Definitely.\r\n\r\nBefore I do that I need to merge this PR, then PR 40 and finally update this section again to avoid merge conflicts.",
              "createdAt": "2025-08-27T14:26:09Z",
              "updatedAt": "2025-08-27T14:26:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM68jPKV",
          "commit": {
            "abbreviatedOid": "5f84be4"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-28T06:24:49Z",
          "updatedAt": "2025-08-28T06:24:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "why not publish PR 40 first and then revise this PR ?",
              "createdAt": "2025-08-28T06:24:50Z",
              "updatedAt": "2025-08-28T06:24:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM683oJ5",
          "commit": {
            "abbreviatedOid": "c63dd4b"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-29T13:15:01Z",
          "updatedAt": "2025-08-29T13:15:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Will do in a separate PR",
              "createdAt": "2025-08-29T13:15:01Z",
              "updatedAt": "2025-08-29T13:15:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOMJPqLM6lGlcx",
      "title": "Reduce the number of handshake messages",
      "url": "https://github.com/tlswg/tls-key-update/pull/40",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF 123",
      "createdAt": "2025-08-24T16:13:22Z",
      "updatedAt": "2025-08-29T12:50:31Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f13a5f08f867b6be656b3467be840ecb31b6e482",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "961669edb1a2b9511ea918d09ec3d8ca76ad91b5",
      "closedAt": "2025-08-29T12:50:28Z",
      "mergedAt": "2025-08-29T12:50:28Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "bf25ead02f927b6454fdaa42013ff879860f5fcb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM67uPmY",
          "commit": {
            "abbreviatedOid": "deb9717"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-24T18:11:22Z",
          "updatedAt": "2025-08-24T18:11:23Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n                                   [ExtendedKeyUpdate(new_key_update)]N\r\n```",
              "createdAt": "2025-08-24T18:11:23Z",
              "updatedAt": "2025-08-24T18:11:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67uPsV",
          "commit": {
            "abbreviatedOid": "657037d"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-24T18:13:02Z",
          "updatedAt": "2025-08-24T18:13:03Z",
          "comments": [
            {
              "originalPosition": 424,
              "body": "```suggestion\r\n                                    [ExtendedKeyUpdate(new_key_update)]\r\n```",
              "createdAt": "2025-08-24T18:13:03Z",
              "updatedAt": "2025-08-24T18:13:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67uQY-",
          "commit": {
            "abbreviatedOid": "81932a0"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-24T18:23:42Z",
          "updatedAt": "2025-08-24T18:23:44Z",
          "comments": [
            {
              "originalPosition": 444,
              "body": "```suggestion\r\n1. `CLIENT_TRAFFIC_SECRET_N+1`: identifies the\r\n```",
              "createdAt": "2025-08-24T18:23:43Z",
              "updatedAt": "2025-08-24T18:23:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67uQjz",
          "commit": {
            "abbreviatedOid": "5cd8bb7"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-24T18:26:52Z",
          "updatedAt": "2025-08-24T18:26:52Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "```suggestion\r\n                                           <--------\r\n```",
              "createdAt": "2025-08-24T18:26:52Z",
              "updatedAt": "2025-08-24T18:26:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yTPf",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T09:01:39Z",
          "updatedAt": "2025-08-25T09:01:39Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "```suggestion\r\nwhen status is set to `retry`.\r\n```",
              "createdAt": "2025-08-25T09:01:39Z",
              "updatedAt": "2025-08-25T09:01:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yUth",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T09:03:38Z",
          "updatedAt": "2025-08-25T09:03:38Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "```suggestion\r\nstatus to `accepted`, the initiator derives the new secrets from the\r\n```\r\n",
              "createdAt": "2025-08-25T09:03:38Z",
              "updatedAt": "2025-08-25T09:04:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yXnp",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T09:06:43Z",
          "updatedAt": "2025-08-25T09:06:43Z",
          "comments": [
            {
              "originalPosition": 273,
              "body": "```suggestion\r\nan appropriate rejection status and omits the `KeyShareEntry`. While an extended\r\n```",
              "createdAt": "2025-08-25T09:06:43Z",
              "updatedAt": "2025-08-25T09:06:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yaEi",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T09:09:35Z",
          "updatedAt": "2025-08-25T09:09:35Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "OLD:\r\nThe subsequent ExtendedKeyUpdate(new_key_update) is an intentionally empty structure that triggers the switch to the new keying material.\r\n\r\nNEW: \r\nThe initiator then sends an empty `ExtendedKeyUpdate(new_key_update)` message to trigger the switch to the new keys.",
              "createdAt": "2025-08-25T09:09:35Z",
              "updatedAt": "2025-08-25T09:17:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yb0w",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T09:11:41Z",
          "updatedAt": "2025-08-25T09:11:42Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "```suggestion\r\n`KeyShareEntry` MUST be rejected with status set to `clashed` in the\r\n```",
              "createdAt": "2025-08-25T09:11:41Z",
              "updatedAt": "2025-08-25T09:11:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM67yfUG",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Most of the changes look good. I identified few nits. ",
          "createdAt": "2025-08-25T09:15:30Z",
          "updatedAt": "2025-08-25T09:15:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM67z-Ix",
          "commit": {
            "abbreviatedOid": "ff624b9"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:05:31Z",
          "updatedAt": "2025-08-25T11:05:31Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "Done.",
              "createdAt": "2025-08-25T11:05:31Z",
              "updatedAt": "2025-08-25T11:05:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM670E7r",
          "commit": {
            "abbreviatedOid": "c0667be"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:15:42Z",
          "updatedAt": "2025-08-25T11:15:43Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I like the suggestion from Ekr to remove clashed, see his comment below:\r\n\r\nI see what \"clashed\" is trying to do, but I think there's another\r\nopportunity to simplify: because you are determining which side wins\r\nbased on information known both sides, they can each independently\r\ndetermine which EKURequest will be accepted and which one will be\r\nrejected [0]. So instead of having the winner send a EKUResponse\r\nrejecting the loser, I suggest it just wait for the EKUResponse\r\nfrom the loser. I.e.,\r\n\r\nClient                                       Server\r\n---------------------------------------------------\r\nEKURequest(share=1) ->       <- EKURequest(share=2)\r\n                                                    [ignores EKURequest]\r\nEKUResponse(share=1) ->\r\n\r\nThis removes one message and simplifies the state machine because the\r\nlosing Initiator can transition directly to sending EKUResponse\r\nwithout having to have a state waiting for the EKUResponse(clashed)\r\nmessage.\r\n",
              "createdAt": "2025-08-25T11:15:43Z",
              "updatedAt": "2025-08-25T11:16:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM670Na_",
          "commit": {
            "abbreviatedOid": "c0667be"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:28:12Z",
          "updatedAt": "2025-08-25T11:28:12Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "```suggestion\r\n4. After the initiator sends `ExtendedKeyUpdate(new_key_update)` it\r\n```",
              "createdAt": "2025-08-25T11:28:12Z",
              "updatedAt": "2025-08-25T11:28:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM670Nlu",
          "commit": {
            "abbreviatedOid": "c0667be"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:28:28Z",
          "updatedAt": "2025-08-25T11:28:28Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "```suggestion\r\n5. After receiving the responder\u2019s `ExtendedKeyUpdate(new_key_update)`,\r\n```",
              "createdAt": "2025-08-25T11:28:28Z",
              "updatedAt": "2025-08-25T11:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM670aAe",
          "commit": {
            "abbreviatedOid": "c0667be"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-08-25T11:46:29Z",
          "updatedAt": "2025-08-25T11:46:30Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "We may want to add the following steps for clarity:\r\n\r\n1. The initiator sends ExtendedKeyUpdate(request) carrying a KeyShareEntry. Only one key update request may be outstanding at a time. This message is sent reliably using DTLS handshake retransmission.\r\n2. Upon receipt, the responder sends ExtendedKeyUpdate(response). If the request is accepted, the response includes a KeyShareEntry; if rejected, it carries a rejection status code and omits the KeyShareEntry. \r\n3. When the initiator receives an accepted response, it derives the new secrets, updates its send keys, and sends ExtendedKeyUpdate(new_key_update) to signal it has switched to the new sending keys. This message also serves as an implicit acknowledgment of the responder\u2019s ExtendedKeyUpdate(response), so no separate ACK is required. \r\n4. Upon receipt of the initiator\u2019s ExtendedKeyUpdate(new_key_update), the responder updates its receive keys and sends its own ExtendedKeyUpdate(new_key_update) to switch its sending keys. This also serves to acknowledge the initiator\u2019s ExtendedKeyUpdate(new_key_update).\r\n5. Upon receipt of the responder\u2019s ExtendedKeyUpdate(new_key_update), the initiator updates its receive keys and sends an ACK message.  If this ACK is not received, the responder re-transmits ExtendedKeyUpdate(new_key_update) until ACK is received. The key update is complete once this ACK is processed by the responder.",
              "createdAt": "2025-08-25T11:46:29Z",
              "updatedAt": "2025-08-25T11:46:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOMJPqLM6l_aJf",
      "title": "Update draft-ietf-tls-extended-key-update.md",
      "url": "https://github.com/tlswg/tls-key-update/pull/42",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-08-29T13:12:25Z",
      "updatedAt": "2025-08-29T13:12:58Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "hannestschofenig-patch-7",
      "baseRefOid": "5f84be41651cd4fdafb4c2d016fe5d266961b5ec",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "9f1b35514bae468a7f09359f7015da3dd53eb08e",
      "closedAt": "2025-08-29T13:12:55Z",
      "mergedAt": "2025-08-29T13:12:54Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "fed0d4b9a9c27cdbbb89ac1c1f9a9caf3d87712b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "PR_kwDOMJPqLM6l_lIP",
      "title": "New Version of the DTLS 1.3 Considerations",
      "url": "https://github.com/tlswg/tls-key-update/pull/43",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-08-29T13:30:22Z",
      "updatedAt": "2025-08-29T13:31:07Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "bf25ead02f927b6454fdaa42013ff879860f5fcb",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "65ae274312d45314069cd4557f9dcd11fca968c5",
      "closedAt": "2025-08-29T13:31:04Z",
      "mergedAt": "2025-08-29T13:31:04Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "f079df600c24e3bc650299ff7e3321341673422b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOMJPqLM6nAsm5",
      "title": "State machine",
      "url": "https://github.com/tlswg/tls-key-update/pull/44",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With this PR I added a state machine to the description in DTLS 1.3\r\n\r\nI also added the SPIN model used to verify correctness of the exchange",
      "createdAt": "2025-09-05T09:12:34Z",
      "updatedAt": "2025-09-07T09:47:31Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f079df600c24e3bc650299ff7e3321341673422b",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "state-machine",
      "headRefOid": "e8b32216b89b4fd87846dbba322088b7110e89fa",
      "closedAt": "2025-09-07T09:47:28Z",
      "mergedAt": "2025-09-07T09:47:28Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "5ff57d805cc569e29e0dde129168f7cda6dd8e55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6-GzEQ",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for providing the updated description, I have only identified an editorial point. The state machine seems fine from my understanding. The other comments mainly relate to the relation of ExtendedKeyUpdate and KeyUpdate.  ",
          "createdAt": "2025-09-05T13:48:30Z",
          "updatedAt": "2025-09-05T14:28:17Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Just as a note, NKU is explained further down as New Key Update, but should be on first occurrence",
              "createdAt": "2025-09-05T13:48:30Z",
              "updatedAt": "2025-09-05T14:28:17Z"
            },
            {
              "originalPosition": 473,
              "body": "I had some rounds of thinking regarding the switch in tx and rx on the client and the server side, but I think it is fine that way. ",
              "createdAt": "2025-09-05T14:11:59Z",
              "updatedAt": "2025-09-05T14:28:17Z"
            },
            {
              "originalPosition": 598,
              "body": "good catch!",
              "createdAt": "2025-09-05T14:17:59Z",
              "updatedAt": "2025-09-05T14:28:17Z"
            },
            {
              "originalPosition": 589,
              "body": "The state machine looks fine from my point of view, thank you for putting it together. \r\nNevertheless, what I need to think through is the part that in case ExtendedKeyUpdate is used, the normal KeyUpdate shall not be used. So essentially, we need to cover the same functionality as in the key update. That said, it might be a silly question, but if ExtendedKeyUpdate is used, it always changes the \"long term secret\". How is the \"normal\" KeyUpdate resembled? In other words how do we distinguish between extended and normal keyUpdate?",
              "createdAt": "2025-09-05T14:26:43Z",
              "updatedAt": "2025-09-05T14:28:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-O_8E",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T05:47:12Z",
          "updatedAt": "2025-09-06T05:47:12Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nSecurity guidance from national agencies, such as ANSSI (France {{ANSSI}}), recommends the\r\n```",
              "createdAt": "2025-09-06T05:47:12Z",
              "updatedAt": "2025-09-06T05:47:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PAnd",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T05:49:19Z",
          "updatedAt": "2025-09-06T05:49:19Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nThe proposed extension is applicable to both TLS 1.3 {{I-D.ietf-tls-rfc8446bis}} and DTLS 1.3  {{RFC9147}}. For clarity,\r\n```",
              "createdAt": "2025-09-06T05:49:19Z",
              "updatedAt": "2025-09-06T05:49:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PDWs",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:02:44Z",
          "updatedAt": "2025-09-06T06:02:44Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "```suggestion\r\n   initiate further key updates. This message is sent reliably using DTLS handshake retransmission.\r\n```",
              "createdAt": "2025-09-06T06:02:44Z",
              "updatedAt": "2025-09-06T06:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PE1V",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:09:45Z",
          "updatedAt": "2025-09-06T06:09:45Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "Step 3 does not specify what happens when the status in ExtendedKeyUpdate(response) is not set to \"accepted\". \r\nI don\u2019t see a need for Step 3, since the responder must send an ExtendedKeyUpdate(response) regardless of whether the status is \"accepted\" or not.",
              "createdAt": "2025-09-06T06:09:45Z",
              "updatedAt": "2025-09-06T06:09:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PFEG",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:11:34Z",
          "updatedAt": "2025-09-06T06:11:35Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "```suggestion\r\n   the initiator sets the local variable `accepted=1` and derives a secret key based on the\r\n```",
              "createdAt": "2025-09-06T06:11:35Z",
              "updatedAt": "2025-09-06T06:11:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PFLB",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:12:34Z",
          "updatedAt": "2025-09-06T06:12:34Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "```suggestion\r\n   exchanged key shares. This message also serves as an implicit acknowledgment of the initiators\u2019s ExtendedKeyUpdate(request), so no separate ACK is required.\r\n```",
              "createdAt": "2025-09-06T06:12:34Z",
              "updatedAt": "2025-09-06T06:12:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PFb4",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:14:52Z",
          "updatedAt": "2025-09-06T06:14:52Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "```suggestion\r\n5. The initiator transmits an `ExtendedKeyUpdate(new_key_update)` message. This message also serves as an implicit acknowledgment of the responder\u2019s ExtendedKeyUpdate(response), so no separate ACK is required.\r\n```",
              "createdAt": "2025-09-06T06:14:52Z",
              "updatedAt": "2025-09-06T06:14:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PGdt",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:21:20Z",
          "updatedAt": "2025-09-06T06:21:20Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "NEW:\r\nDue to packet loss and/or reordering, DTLS 1.3 peers MAY receive records from an earlier epoch. If the necessary keys are available, implementations SHOULD attempt to process such records; however, they MAY choose to discard them.",
              "createdAt": "2025-09-06T06:21:20Z",
              "updatedAt": "2025-09-06T06:21:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PG99",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:25:07Z",
          "updatedAt": "2025-09-06T06:25:07Z",
          "comments": [
            {
              "originalPosition": 228,
              "body": "```suggestion\r\n    value. If this ACK is not received, the responder re-transmits ExtendedKeyUpdate(new_key_update) until ACK is received. The key update is complete once this ACK is processed by the responder.\r\n```",
              "createdAt": "2025-09-06T06:25:07Z",
              "updatedAt": "2025-09-06T06:25:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-PH3d",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T06:32:05Z",
          "updatedAt": "2025-09-06T06:32:05Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "what is NKU ?",
              "createdAt": "2025-09-06T06:32:05Z",
              "updatedAt": "2025-09-06T06:32:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-RqLc",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T11:18:18Z",
          "updatedAt": "2025-09-06T11:18:18Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n- e==... - the epoch tag carried on an incoming message (what the peer sent).\r\n```",
              "createdAt": "2025-09-06T11:18:18Z",
              "updatedAt": "2025-09-06T11:18:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Ryni",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T11:31:49Z",
          "updatedAt": "2025-09-06T11:31:49Z",
          "comments": [
            {
              "originalPosition": 280,
              "body": "what about messages like DTLS heartbeat ? ",
              "createdAt": "2025-09-06T11:31:49Z",
              "updatedAt": "2025-09-06T11:31:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-R0Bo",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T11:34:30Z",
          "updatedAt": "2025-09-06T11:34:30Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "Any specific reason for the state machine not being depicted in the Appendix (for instance, see https://datatracker.ietf.org/doc/html/rfc8446#appendix-A.1) ?",
              "createdAt": "2025-09-06T11:34:30Z",
              "updatedAt": "2025-09-06T11:34:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-SAtZ",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T11:49:05Z",
          "updatedAt": "2025-09-06T11:49:05Z",
          "comments": [
            {
              "originalPosition": 508,
              "body": "The above table does not align with the following step:\r\n\r\nAfter the initiator receives the responder\u2019s ExtendedKeyUpdate(new_key_update), the initiator MUST update its send key and epoch value. With the receipt of that message, the initiator MUST also update its receive keys.\r\n\r\n",
              "createdAt": "2025-09-06T11:49:05Z",
              "updatedAt": "2025-09-06T11:49:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-SClf",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The PR is awesome, Thanks.",
          "createdAt": "2025-09-06T11:51:02Z",
          "updatedAt": "2025-09-06T11:51:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM6-SyhX",
          "commit": {
            "abbreviatedOid": "65f32ce"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T12:42:41Z",
          "updatedAt": "2025-09-06T12:42:41Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "```suggestion\r\n                                        # Server derives new secrets\r\n```",
              "createdAt": "2025-09-06T12:42:41Z",
              "updatedAt": "2025-09-06T12:42:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-SyxT",
          "commit": {
            "abbreviatedOid": "65f32ce"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T12:42:58Z",
          "updatedAt": "2025-09-06T12:42:59Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n                               <--------\r\n```",
              "createdAt": "2025-09-06T12:42:58Z",
              "updatedAt": "2025-09-06T12:42:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Sy5u",
          "commit": {
            "abbreviatedOid": "65f32ce"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T12:43:11Z",
          "updatedAt": "2025-09-06T12:43:11Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "```suggestion\r\n                                    # Server updates SEND keys here\r\n```",
              "createdAt": "2025-09-06T12:43:11Z",
              "updatedAt": "2025-09-06T12:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-S1oj",
          "commit": {
            "abbreviatedOid": "ec2cf6c"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T12:46:38Z",
          "updatedAt": "2025-09-06T12:46:38Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "The message per se is not sent reliably without the response message, which gives the sender an assurance that the request message has indeed arrived.",
              "createdAt": "2025-09-06T12:46:38Z",
              "updatedAt": "2025-09-06T12:46:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-S5mu",
          "commit": {
            "abbreviatedOid": "ea02538"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T12:51:40Z",
          "updatedAt": "2025-09-06T12:51:40Z",
          "comments": [
            {
              "originalPosition": 589,
              "body": "The normal key update uses different messages. So, it is easy to differentiate from the new functionality. When the peers negotiate the extended key update then the normal key update is not used. ",
              "createdAt": "2025-09-06T12:51:40Z",
              "updatedAt": "2025-09-06T12:51:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Tm3J",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T13:57:29Z",
          "updatedAt": "2025-09-06T13:57:29Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "we may want to add: This message is subject to DTLS handshake retransmission, but delivery is only\r\nconfirmed when the initiator receives the corresponding `ExtendedKeyUpdate(response)`.",
              "createdAt": "2025-09-06T13:57:29Z",
              "updatedAt": "2025-09-06T13:57:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-UtZx",
          "commit": {
            "abbreviatedOid": "7e3b7cf"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T15:39:55Z",
          "updatedAt": "2025-09-06T15:39:55Z",
          "comments": [
            {
              "originalPosition": 280,
              "body": "Good question. I think we have to state what handshake messages are allowed interleaving the extended key update.\r\nSince we do not permit the traditional key update and, based on the most recent discussions, also no ticket exchanges I believe all other handshake messages are pretty much treated like application data.\r\n\r\nI will, however, extend the formal to verify this statement.",
              "createdAt": "2025-09-06T15:39:55Z",
              "updatedAt": "2025-09-06T15:39:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-UuGi",
          "commit": {
            "abbreviatedOid": "7e3b7cf"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T15:41:05Z",
          "updatedAt": "2025-09-06T15:41:05Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "No, there is no reason. I can move those to the appendix, if you think it is better. Happy to do this in a separate PR.",
              "createdAt": "2025-09-06T15:41:05Z",
              "updatedAt": "2025-09-06T15:41:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-WY0C",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-06T18:06:40Z",
          "updatedAt": "2025-09-06T18:06:40Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "New Key Update. I improved the description ",
              "createdAt": "2025-09-06T18:06:40Z",
              "updatedAt": "2025-09-06T18:06:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ZbvU",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T09:45:20Z",
          "updatedAt": "2025-09-07T09:45:20Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Updated the text.",
              "createdAt": "2025-09-07T09:45:20Z",
              "updatedAt": "2025-09-07T09:45:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ZbyD",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T09:45:55Z",
          "updatedAt": "2025-09-07T09:45:55Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "I improved the text.",
              "createdAt": "2025-09-07T09:45:55Z",
              "updatedAt": "2025-09-07T09:45:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Zb5C",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T09:46:36Z",
          "updatedAt": "2025-09-07T09:46:36Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Done.",
              "createdAt": "2025-09-07T09:46:36Z",
              "updatedAt": "2025-09-07T09:46:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Zb71",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T09:46:58Z",
          "updatedAt": "2025-09-07T09:46:58Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "Add separate issue.",
              "createdAt": "2025-09-07T09:46:58Z",
              "updatedAt": "2025-09-07T09:46:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Zb-j",
          "commit": {
            "abbreviatedOid": "3b0a70e"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T09:47:19Z",
          "updatedAt": "2025-09-07T09:47:19Z",
          "comments": [
            {
              "originalPosition": 508,
              "body": "Updated table.",
              "createdAt": "2025-09-07T09:47:19Z",
              "updatedAt": "2025-09-07T09:47:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOMJPqLM6nPv04",
      "title": "Move State Machines to Appendix",
      "url": "https://github.com/tlswg/tls-key-update/pull/49",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-07T09:53:38Z",
      "updatedAt": "2025-09-07T10:08:30Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "5ff57d805cc569e29e0dde129168f7cda6dd8e55",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "783b34c7795d4433eb8fd68176248163c3000bda",
      "closedAt": "2025-09-07T10:08:27Z",
      "mergedAt": "2025-09-07T10:08:27Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "361eb6c136c5e15d4379ee3263e116220aaf3aa1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOMJPqLM6nP4QG",
      "title": "Added DTLS Handshake Structure",
      "url": "https://github.com/tlswg/tls-key-update/pull/50",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-07T10:26:21Z",
      "updatedAt": "2025-09-07T18:00:22Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "361eb6c136c5e15d4379ee3263e116220aaf3aa1",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "7bcb11ff851697b93b030b85932448b8eb27ae06",
      "closedAt": "2025-09-07T18:00:18Z",
      "mergedAt": "2025-09-07T18:00:18Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "9f75ae4ed146b7ae57ad19048ae2917b245f78ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6-ZtxU",
          "commit": {
            "abbreviatedOid": "7bcb11f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-07T11:53:56Z",
          "updatedAt": "2025-09-07T11:53:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOMJPqLM6nP5yk",
      "title": "Added TLS 1.3 State Machine",
      "url": "https://github.com/tlswg/tls-key-update/pull/51",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-07T10:32:26Z",
      "updatedAt": "2025-09-10T16:11:11Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "361eb6c136c5e15d4379ee3263e116220aaf3aa1",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6-1",
      "headRefOid": "bf2c1b4e96533b885310dfff649a64b6a2178dd9",
      "closedAt": "2025-09-10T16:11:08Z",
      "mergedAt": "2025-09-10T16:11:08Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "6695fd1af6d6f17559c8dfdb439077570197ef8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6-Zuip",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T12:02:23Z",
          "updatedAt": "2025-09-07T12:02:23Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "tx and rx are DTLS epoch and are not applicable to TLS. Please replace tx/rx with send_key/receive_key and replace N/N+1 with current/new keying material.",
              "createdAt": "2025-09-07T12:02:23Z",
              "updatedAt": "2025-09-07T12:02:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ZusE",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T12:03:53Z",
          "updatedAt": "2025-09-07T12:03:53Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Same comment as above. ",
              "createdAt": "2025-09-07T12:03:53Z",
              "updatedAt": "2025-09-07T12:03:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-Zuul",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The state machine needs to be updated.",
          "createdAt": "2025-09-07T12:04:18Z",
          "updatedAt": "2025-09-07T12:04:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM6-aHCw",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T16:31:40Z",
          "updatedAt": "2025-09-07T16:44:33Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Same applies to `rx`, `tx`, `E`, `old_rx`, `retain_old`, `tag` and `e` definitions in the section above. They need to be moved to DTLS specific sub-section otherwise it is confusing to the reader who do not care about DTLS that much",
              "createdAt": "2025-09-07T16:31:41Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 9,
              "body": "Let's drop imaginary epoch from TLS. It is very confusing.",
              "createdAt": "2025-09-07T16:34:11Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 13,
              "body": "I don't think we defined `NKU` anywhere. Worth defining this acronym.",
              "createdAt": "2025-09-07T16:35:35Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 13,
              "body": "I thought the process starts with `extended_key_update_request`... Why do we talk about NKU here?",
              "createdAt": "2025-09-07T16:40:03Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 17,
              "body": "Maybe use aasvg?",
              "createdAt": "2025-09-07T16:40:52Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 32,
              "body": "FWIW based on feedback from the last meeting we will be removing retry or clashed. Perhaps it needs to be covered in a separate PR",
              "createdAt": "2025-09-07T16:42:00Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 30,
              "body": "There is another potential outcome - timeout. That is, initiator sent the request and got tired of waiting for the response. In that case the only thing initiator can do is terminate the session.",
              "createdAt": "2025-09-07T16:43:14Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            },
            {
              "originalPosition": 58,
              "body": "As above, would be great to start explanation with the beginning of the process.",
              "createdAt": "2025-09-07T16:44:01Z",
              "updatedAt": "2025-09-07T16:44:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-aLgs",
          "commit": {
            "abbreviatedOid": "bf2c1b4"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T17:37:09Z",
          "updatedAt": "2025-09-07T17:37:09Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "It definitely needs a separate PR",
              "createdAt": "2025-09-07T17:37:09Z",
              "updatedAt": "2025-09-07T17:37:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-aL6n",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T17:38:37Z",
          "updatedAt": "2025-09-07T17:38:37Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I thought reusing the terms would be a good idea. From the feedback so far it does not seem so.\r\n\r\nHence, I have changed the text and I hope I didn't miss anything!",
              "createdAt": "2025-09-07T17:38:37Z",
              "updatedAt": "2025-09-07T17:38:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-aL9L",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T17:39:16Z",
          "updatedAt": "2025-09-07T17:39:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I remove the brief description and added terminology at the start of the section.",
              "createdAt": "2025-09-07T17:39:16Z",
              "updatedAt": "2025-09-07T17:39:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-aL9g",
          "commit": {
            "abbreviatedOid": "eec5d56"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T17:39:24Z",
          "updatedAt": "2025-09-07T17:39:25Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done",
              "createdAt": "2025-09-07T17:39:24Z",
              "updatedAt": "2025-09-07T17:39:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOMJPqLM6nP9RL",
      "title": "Adding TLS 1.3 SPIN Model",
      "url": "https://github.com/tlswg/tls-key-update/pull/52",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-07T10:58:24Z",
      "updatedAt": "2025-09-10T16:44:58Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "361eb6c136c5e15d4379ee3263e116220aaf3aa1",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "model-tls13",
      "headRefOid": "5497ecb97c83f3b3e9c42fe89e69804bfecf85dd",
      "closedAt": "2025-09-10T16:44:55Z",
      "mergedAt": "2025-09-10T16:44:54Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "a9f87d9baee2d22aac68031a7743aa12705939be"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "For the initial version I only provided a minimal version because Yaroslav wanted to make some further changes to the draft based on the error handling (see #41).",
          "createdAt": "2025-09-07T17:47:50Z",
          "updatedAt": "2025-09-07T17:47:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6-ZyFt",
          "commit": {
            "abbreviatedOid": "c940142"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T12:39:02Z",
          "updatedAt": "2025-09-07T12:39:03Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "It only tests positive case and not the failure scenarios, we need to test reject scenarios as well.\r\nif\r\n:: /* accept path */\r\n   accepted = 1;\r\n   c_srv_to_cli ! Resp_acc, group;\r\n:: /* retry path */\r\n   accepted = 0;\r\n   c_srv_to_cli ! Resp_retry, group;\r\n:: /* reject path */\r\n   accepted = 0;\r\n   c_srv_to_cli ! Resp_rej, group;\r\n:: /* clash path */\r\n   accepted = 0;\r\n   c_srv_to_cli ! Resp_clashed, group;\r\nfi;\r\n",
              "createdAt": "2025-09-07T12:39:02Z",
              "updatedAt": "2025-09-07T12:39:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ZyLA",
          "commit": {
            "abbreviatedOid": "c940142"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-07T12:39:55Z",
          "updatedAt": "2025-09-07T12:39:55Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "if\r\n:: (accepted) ->\r\n     assert(tx == E+1 && rx == E+1) /* both sides advanced */\r\n:: else ->\r\n     assert(tx == E && rx == E)     /* no advancement if not accepted */\r\nfi;",
              "createdAt": "2025-09-07T12:39:55Z",
              "updatedAt": "2025-09-07T12:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOMJPqLM6nRGrM",
      "title": "Replaced ExtendedKeyUpdate with PostHandshakeMessage",
      "url": "https://github.com/tlswg/tls-key-update/pull/53",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For future extensibility I replaced ExtendedKeyUpdate with PostHandshakeMessage that defines its own 2-byte types driven by IANA registry. This way we won't be constrained by the total of 255 handshake and post-handshake message types and can be a bit more relaxed about extending post-handshake TLS for things such as Classic McEliece, attestation and whatever comes next.\r\n\r\nAs suggested by Ekr I also cleaned up response code down to 2 - accepted and rejected. Added text to describe what to do in case of limited resources on responder for both TLS and DTLS.",
      "createdAt": "2025-09-07T19:31:30Z",
      "updatedAt": "2025-09-17T19:16:52Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "a9f87d9baee2d22aac68031a7743aa12705939be",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "main",
      "headRefOid": "b4f1747a93edc9eca0ac19cfc5c83e8218b60d7a",
      "closedAt": "2025-09-17T19:16:51Z",
      "mergedAt": "2025-09-17T19:16:51Z",
      "mergedBy": "yaroslavros",
      "mergeCommit": {
        "oid": "dcb5c89c0eb17c60ff37b4ca673eafe5d93e35e0"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "It took me a while to read through this exchange. There a number of topics to discuss and a call might indeed be appropriate. ",
          "createdAt": "2025-09-10T16:00:10Z",
          "updatedAt": "2025-09-10T16:00:10Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed, merging the PR after updates",
          "createdAt": "2025-09-17T19:16:46Z",
          "updatedAt": "2025-09-17T19:16:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6-bz6L",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Changes look good except for removing \"retry\". ",
          "createdAt": "2025-09-08T04:56:49Z",
          "updatedAt": "2025-09-08T05:05:57Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "It makes sense to remove \"clashed\" because the request with lower lexicographic order of the key_exchange value must be ignored but disagree with the change to remove \"retry\". \r\nwhy did you remove retry ? ",
              "createdAt": "2025-09-08T04:56:49Z",
              "updatedAt": "2025-09-08T05:05:57Z"
            },
            {
              "originalPosition": 181,
              "body": "The initiator will have no clue why the responder is not sending a response ?",
              "createdAt": "2025-09-08T05:01:41Z",
              "updatedAt": "2025-09-08T05:05:57Z"
            },
            {
              "originalPosition": 306,
              "body": "The imitator will have no clue when the responder will provide a response, I don't agree with this change. ",
              "createdAt": "2025-09-08T05:05:11Z",
              "updatedAt": "2025-09-08T05:05:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-cZiM",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:24:12Z",
          "updatedAt": "2025-09-08T06:24:12Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Other than winning the clashed update election (and the peer knows if this happens), I do not think the initiator needs to know why the response is delayed. The delayed response will just freeze the EKU process.",
              "createdAt": "2025-09-08T06:24:12Z",
              "updatedAt": "2025-09-08T06:24:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-cbD7",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:27:10Z",
          "updatedAt": "2025-09-08T06:27:10Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Note that the response can be delayed for other reasons beyond just responder not processing the request immediately. E.g., network delays (especially with unreliable/DTLS).",
              "createdAt": "2025-09-08T06:27:10Z",
              "updatedAt": "2025-09-08T06:27:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-cdWP",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:31:16Z",
          "updatedAt": "2025-09-08T06:31:17Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "I do not think retry is needed, as both sides can freeze the process by delaying the response. And because there can only ever be one outstanding EKU, the peers only ever need to buffer one key/ciphertext to do so.",
              "createdAt": "2025-09-08T06:31:16Z",
              "updatedAt": "2025-09-08T06:31:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-chGu",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:37:56Z",
          "updatedAt": "2025-09-08T06:37:57Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "This seems a bit unclear to me. \"a group that that was negotiated\" would suggest there may be multiple negotiated groups. What determines what groups are negotiated? I presume if using DHE, then the the DHE group used by the server is considered negotiated (even if it is actually a KEM). However, if the server sends supported_groups (which is optional!), are the overlapping groups with client also considered supported?",
              "createdAt": "2025-09-08T06:37:57Z",
              "updatedAt": "2025-09-08T06:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ckmf",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:43:29Z",
          "updatedAt": "2025-09-08T06:43:30Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "\"rejected\" seems bit odd, as it would seemingly permanently jam the EKU mechanism in one direction. What are use-cases for that? I think overload can be handled by delaying response, and peers that spam EKU can be disconnected (as this is indistinguishable from an attack).",
              "createdAt": "2025-09-08T06:43:29Z",
              "updatedAt": "2025-09-08T06:43:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-cqLe",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:50:39Z",
          "updatedAt": "2025-09-08T06:50:39Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "If initiator gets in unexpected overload situation, it might make sense to freeze the process at this state until the overload ablates. If this happens, the initiator should send an immediate ACK, and then key_update_request after the overload has ended.",
              "createdAt": "2025-09-08T06:50:39Z",
              "updatedAt": "2025-09-08T06:50:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-cvXQ",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T06:59:03Z",
          "updatedAt": "2025-09-08T06:59:04Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "Why is this Standards Action? I do not see any >=16-bit TLS registries that are Standards Action (one seems to be IETF Review, all others seem to be Specification Required or Expert Review).",
              "createdAt": "2025-09-08T06:59:03Z",
              "updatedAt": "2025-09-08T06:59:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-frgJ",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:45:00Z",
          "updatedAt": "2025-09-08T10:45:00Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Removing retry was discussed at last IETF meeting. Ekr's argument was that proposed retry mechanism create unnecessary complexity, it's easier for responder to simply delay the response.",
              "createdAt": "2025-09-08T10:45:00Z",
              "updatedAt": "2025-09-08T10:58:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-fsbT",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:46:24Z",
          "updatedAt": "2025-09-08T10:46:24Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Correct. With TLS initiator knows that request will be delivered and needs to simply wait - and drop the connection if the wait was too long. In case of DTLS responder needs to confirm with an ACK so that initiator would not retransmit.",
              "createdAt": "2025-09-08T10:46:24Z",
              "updatedAt": "2025-09-08T10:46:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-ftx6",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:48:22Z",
          "updatedAt": "2025-09-08T10:48:22Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Again, if the wait is too long, initiator can drop the connection (what else can it do?)",
              "createdAt": "2025-09-08T10:48:22Z",
              "updatedAt": "2025-09-08T10:48:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-fvA-",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:50:09Z",
          "updatedAt": "2025-09-08T10:50:09Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "I had objected to this change at the WG meeting. The initiator will have no clue how long it will have to wait for the responder to respond. I don't get the complexity (it is similar to Retry-After in HTTP). ",
              "createdAt": "2025-09-08T10:50:09Z",
              "updatedAt": "2025-09-08T10:50:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-fw5K",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:52:48Z",
          "updatedAt": "2025-09-08T10:52:48Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Actually this change was supposed to clarify the point. Previously it said\r\n```\r\nMUST use a group that was mutually supported by the client and server during the initial handshake.\r\n```\r\n\r\n\"supported\" does not necessarily mean the group that was used during the handshake - hence this could create a risk of downgrade attacks.\r\n\r\nWould\r\n```\r\nMUST use the group\r\n```\r\nmake it better?",
              "createdAt": "2025-09-08T10:52:48Z",
              "updatedAt": "2025-09-08T10:52:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-fzjN",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:55:56Z",
          "updatedAt": "2025-09-08T10:55:57Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "This is an interesting call. Given that now Extended Key Update always disables standard Key Update rejecting is perhaps no longer acceptable option.\r\nWhich means we can get rid of `ExtendedKeyUpdateResponseStatus` completely.",
              "createdAt": "2025-09-08T10:55:57Z",
              "updatedAt": "2025-09-08T10:55:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-f0o-",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:57:29Z",
          "updatedAt": "2025-09-08T10:57:29Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "I think this should go into a separate PR...",
              "createdAt": "2025-09-08T10:57:29Z",
              "updatedAt": "2025-09-08T10:57:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-f1U6",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T10:58:27Z",
          "updatedAt": "2025-09-08T10:58:27Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "I simply cloned policy from TLS HandshakeType which was perhaps short-sighted.\r\nWhich IANA policy would you suggest?",
              "createdAt": "2025-09-08T10:58:27Z",
              "updatedAt": "2025-09-08T10:58:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gOFB",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T11:31:00Z",
          "updatedAt": "2025-09-08T11:31:00Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Updated PR accordingly. Please review.",
              "createdAt": "2025-09-08T11:31:00Z",
              "updatedAt": "2025-09-08T11:31:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gOYa",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T11:31:25Z",
          "updatedAt": "2025-09-08T11:31:25Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Updated PR accordingly. Please suggest further improvement.",
              "createdAt": "2025-09-08T11:31:25Z",
              "updatedAt": "2025-09-08T11:31:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gYWc",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T11:45:07Z",
          "updatedAt": "2025-09-08T11:45:07Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "I am working on a prototype implementation of EKU for rustls and I have to say that removing retry simplifies things dramatically from implementation perspective - especially given that rustls is abstracted away from IO or timers.\r\nThis seems to be quite straightforward to me given that implicit delay on responder accomplishes pretty much the same outcome as explicit retry but makes implementation much simpler.\r\nAnyone else have an opinion? @hannestschofenig , @tuexen , @stfries ?",
              "createdAt": "2025-09-08T11:45:07Z",
              "updatedAt": "2025-09-08T11:45:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gf86",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T11:55:17Z",
          "updatedAt": "2025-09-08T11:55:17Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "The initiator will keep re-transmitting the request until a timeout and the behavior is \r\n\r\n> Note that the response can be delayed for other reasons beyond just responder not processing the request immediately. E.g., network delays (especially with unreliable/DTLS).\r\n\r\nThe initiator will keep re-transmitting the request until a timeout and the behavior is defined is DTLS 1.3. ",
              "createdAt": "2025-09-08T11:55:17Z",
              "updatedAt": "2025-09-08T11:55:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gm4B",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:04:26Z",
          "updatedAt": "2025-09-08T12:04:26Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "ExtendedKeyUpdateResponseStatus helps to deal with various types of errors, for example, the initiator uses a group that is not negotiated during the initial handshake, ",
              "createdAt": "2025-09-08T12:04:26Z",
              "updatedAt": "2025-09-08T12:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gqPw",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:08:45Z",
          "updatedAt": "2025-09-08T12:08:45Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "> If initiator gets in unexpected overload situation, it might make sense to freeze the process at this state until the overload ablates. If this happens, the initiator should send an immediate ACK, and then key_update_request after the overload has ended.\r\n\r\nThe responder could get into a unexpected overload situation, why would the initiator get into an unexpected overload situation ?\r\nThe current mechanism \"retry\" allows the initiator to send the request again after the \"delay\" seconds conveyed by the responder.",
              "createdAt": "2025-09-08T12:08:45Z",
              "updatedAt": "2025-09-08T12:08:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-gtRA",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I suggest the authors have a call before committing this PR. ",
          "createdAt": "2025-09-08T12:12:56Z",
          "updatedAt": "2025-09-08T12:13:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "https://datatracker.ietf.org/doc/draft-ietf-tls-tlsflags/ is for new extensions only and this draft is now defining a new message type, It looks like a violation to me. This PR needs further discussion. ",
              "createdAt": "2025-09-08T12:12:56Z",
              "updatedAt": "2025-09-08T12:13:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-g7yy",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:30:04Z",
          "updatedAt": "2025-09-08T12:30:04Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Yes, not having any things explicitly tied to time is easier when I/O and timers are abstracted away. Waiting for some duration is annoying in such architecture. Arranging a callback from internal thread is easy to get wrong in a way that sometimes deadlocks.\r\n\r\nFurthermore, the usual recommendations for re-keying have both time and data transferred, so connections that transfer data faster should re-key more often.",
              "createdAt": "2025-09-08T12:30:04Z",
              "updatedAt": "2025-09-08T12:31:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hBnS",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:36:57Z",
          "updatedAt": "2025-09-08T12:36:57Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "If the responder is overloaded, it can buffer the public key (there can only be one, and keys are <2kB) and ACK the request. That stops re-transmits while still freezing the EKU process.",
              "createdAt": "2025-09-08T12:36:57Z",
              "updatedAt": "2025-09-08T12:36:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hPwN",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:49:22Z",
          "updatedAt": "2025-09-08T12:49:23Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "The only error cases I can come up with are either explicitly or presumably fatal errors, I do not think there are any error cases that need to be recoverable.",
              "createdAt": "2025-09-08T12:49:23Z",
              "updatedAt": "2025-09-08T12:50:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hVFd",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:53:47Z",
          "updatedAt": "2025-09-08T12:53:47Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Initiator using a group that is not negotiated during the initial handshake is a potential downgrade attempt and is a fatal error. Connection must be killed if that happens.",
              "createdAt": "2025-09-08T12:53:47Z",
              "updatedAt": "2025-09-08T12:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hXXA",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:55:08Z",
          "updatedAt": "2025-09-08T12:55:08Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "Retry would not help here, because it is initiator that is in overload, not responder.\r\n\r\nAnd as to why, the initiator might not have been in overload when it decided to start the EKU process, but then got into overload situation while waiting for response. And endpoints can have many connections open at once, so it might not be this connection that caused the overload (those connections might have not even existed yet).",
              "createdAt": "2025-09-08T12:55:08Z",
              "updatedAt": "2025-09-08T12:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hak9",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T12:58:30Z",
          "updatedAt": "2025-09-08T12:58:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Not sure if I follow. We always defined a new message type. Which is an extension to the TLS 1.3 protocol.\r\nAlso why do you say that TLS flags are \"for new extensions only\"?\r\nSure, let's arrange a call.",
              "createdAt": "2025-09-08T12:58:30Z",
              "updatedAt": "2025-09-08T12:58:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-hkej",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-08T13:09:51Z",
          "updatedAt": "2025-09-08T13:09:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The only limitation of TLS flags with respect to TLS extensions is that there can be no request data (the lack of response data can be waived away, but doing this is very Bad Idea). And TLS extensions have extremely wide latitude to change things (there is a **really** blatant example of doing this).",
              "createdAt": "2025-09-08T13:09:51Z",
              "updatedAt": "2025-09-08T13:09:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-uzKN",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T08:03:35Z",
          "updatedAt": "2025-09-09T08:03:36Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Yes and ExtendedKeyUpdateResponseStatus can be leveraged to convey that it is fatal error. ",
              "createdAt": "2025-09-09T08:03:36Z",
              "updatedAt": "2025-09-09T08:03:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-vPa0",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T08:26:15Z",
          "updatedAt": "2025-09-09T08:26:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Not sure if I follow. We always defined a new message type. Which is an extension to the TLS 1.3 protocol. Also why do you say that TLS flags are \"for new extensions only\"? Sure, let's arrange a call.\r\n\r\nThe TLS flags draft explicitly says it is for new extensions only.  Any other specification which defined a new message type that leveraged TLS flags ?",
              "createdAt": "2025-09-09T08:26:15Z",
              "updatedAt": "2025-09-09T08:58:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-vzXb",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T08:55:02Z",
          "updatedAt": "2025-09-09T08:55:02Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "In TLS alerts are used to convey errors, not extensions.",
              "createdAt": "2025-09-09T08:55:02Z",
              "updatedAt": "2025-09-09T08:55:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-v6fM",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T09:00:12Z",
          "updatedAt": "2025-09-09T09:00:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Certificate Update proposal that you and I co-authored did exactly that - in fact it introduced two new message types (Section 9.2 of draft-rosomakho-tls-cert-update)\r\n\r\nThere is no existing message that we could fit Extended Key Update into - that's why we are introducing at least one new message type. Idea behind `PostHandshakeMessage` is to simplify potential future post handshake additions and not eat into the very limited space of handshake message types every time someone wants to introduce something.",
              "createdAt": "2025-09-09T09:00:12Z",
              "updatedAt": "2025-09-09T09:00:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-wRPe",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T09:17:14Z",
          "updatedAt": "2025-09-09T09:17:14Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Yes, I was thinking if there would be the need to signal any type of warnings but can't think of any (like the no_renegotiation in TLS 1.2). ",
              "createdAt": "2025-09-09T09:17:14Z",
              "updatedAt": "2025-09-09T09:17:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-xFyx",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T09:50:44Z",
          "updatedAt": "2025-09-09T09:50:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "draft-ietf-tls-tlsflags prohibits the use of a flag to signal an actual extension, it says:\r\n\r\n   For a flag that does require a response, the only proper response is\r\n   the same flag in a flags extension.  This extension MUST NOT be used\r\n   to specify extensions where the response is a proper extension with\r\n   content.",
              "createdAt": "2025-09-09T09:50:44Z",
              "updatedAt": "2025-09-09T09:50:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-xxrq",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T10:20:57Z",
          "updatedAt": "2025-09-09T10:20:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"flag that does require a response, the only proper response is the same flag in a flags extension\" to me does nto translate into \"prohibits the use of a flag to signal an actual extension\". If that was the case - what's the point at all in TLS flags? Use them to set a flag to respond with a flag and... do nothing?\r\n\r\nIn our case response to a flag in ClientHello is a flag in EncryptedExtensions. We are not proposing an extension response. In fact, we are not specifying any \"extensions with content\" for existing TLS messages.",
              "createdAt": "2025-09-09T10:20:57Z",
              "updatedAt": "2025-09-09T10:20:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6-zwqM",
          "commit": {
            "abbreviatedOid": "7220589"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-09T12:19:23Z",
          "updatedAt": "2025-09-09T12:19:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We will have to discuss this in the TLS WG. The draft is targeted for extensions that do not carry any content, except the 1-bit indication that a certain optional feature is supported.  The example given in the draft is ietf-tls-tls13-cert-with-extern-psk.  ",
              "createdAt": "2025-09-09T12:19:23Z",
              "updatedAt": "2025-09-09T12:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_JCRC",
          "commit": {
            "abbreviatedOid": "08cbbb9"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T15:55:21Z",
          "updatedAt": "2025-09-10T15:55:21Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "We could use the approach from the ClientCertificateType registry, which uses different policies for different ranges. I personally would be fine with a simple \"Specification Required\" policy.\r\n\r\n-  TLS ClientCertificateType Identifiers Registry: Future values in\r\n      the range 0-63 (decimal) inclusive are assigned via Standards\r\n      Action [[RFC2434](https://www.rfc-editor.org/rfc/rfc2434)].  Values in the range 64-223 (decimal) inclusive\r\n      are assigned via Specification Required [[RFC2434](https://www.rfc-editor.org/rfc/rfc2434)].  Values from\r\n      224-255 (decimal) inclusive are reserved for Private Use\r\n      [[RFC2434](https://www.rfc-editor.org/rfc/rfc2434)].",
              "createdAt": "2025-09-10T15:55:21Z",
              "updatedAt": "2025-09-10T15:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7A3-8A",
          "commit": {
            "abbreviatedOid": "8224dba"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-17T19:14:27Z",
          "updatedAt": "2025-09-17T19:14:28Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "```suggestion\r\n              case client_hello:          ClientHello;\r\n              case server_hello:          ServerHello;\r\n              case end_of_early_data:     EndOfEarlyData;\r\n              case encrypted_extensions:  EncryptedExtensions;\r\n              case certificate_request:   CertificateRequest;\r\n              case certificate:           Certificate;\r\n              case certificate_verify:    CertificateVerify;\r\n              case finished:              Finished;\r\n              case new_session_ticket:    NewSessionTicket;\r\n              case key_update:            KeyUpdate;\r\n              case extended_key_update:   ExtendedKeyUpdate;\r\n```",
              "createdAt": "2025-09-17T19:14:28Z",
              "updatedAt": "2025-09-17T19:14:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7A3_j5",
          "commit": {
            "abbreviatedOid": "19d5e70"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-17T19:15:30Z",
          "updatedAt": "2025-09-17T19:15:31Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "```suggestion\r\n               case client_hello:          ClientHello;\r\n               case server_hello:          ServerHello;\r\n               case end_of_early_data:     EndOfEarlyData;\r\n               case encrypted_extensions:  EncryptedExtensions;\r\n               case certificate_request:   CertificateRequest;\r\n               case certificate:           Certificate;\r\n               case certificate_verify:    CertificateVerify;\r\n               case finished:              Finished;\r\n               case new_session_ticket:    NewSessionTicket;\r\n               case key_update:            KeyUpdate;\r\n               case extended_key_update:   ExtendedKeyUpdate;\r\n               case request_connection_id: RequestConnectionId;\r\n               case new_connection_id:     NewConnectionId;\r\n```",
              "createdAt": "2025-09-17T19:15:30Z",
              "updatedAt": "2025-09-17T19:15:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOMJPqLM6n2kH_",
      "title": "More comments to the TLS 1.3 model",
      "url": "https://github.com/tlswg/tls-key-update/pull/54",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-10T16:37:02Z",
      "updatedAt": "2025-09-10T16:44:26Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "model-tls13",
      "baseRefOid": "e7d5a7dadc551009aceb8727b63c1f2d7c098d19",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "d300a90cf0c042af7b92a7bf44de692dbeedcfa2",
      "closedAt": "2025-09-10T16:44:22Z",
      "mergedAt": "2025-09-10T16:44:22Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "5497ecb97c83f3b3e9c42fe89e69804bfecf85dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM6_Jj0p",
          "commit": {
            "abbreviatedOid": "9c13ab8"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:38:51Z",
          "updatedAt": "2025-09-10T16:38:51Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n    byte send_key = E;      /* send key, initially E */\r\n```",
              "createdAt": "2025-09-10T16:38:51Z",
              "updatedAt": "2025-09-10T16:38:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_JkDy",
          "commit": {
            "abbreviatedOid": "9c13ab8"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:39:06Z",
          "updatedAt": "2025-09-10T16:39:06Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n    byte receive_key = E;   /* receive key, initially E */\r\n```",
              "createdAt": "2025-09-10T16:39:06Z",
              "updatedAt": "2025-09-10T16:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_Jkl1",
          "commit": {
            "abbreviatedOid": "288d9e0"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:39:50Z",
          "updatedAt": "2025-09-10T16:39:50Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n * TLS 1.3 Extended Key Update (EKU) - SPIN Model\r\n  *\r\n * State/variable conventions (aligned with DTLS model where sensible):\r\n *   - send_key, receive_key : generation counters of application_traffic_secret (current, new keying material, ...)\r\n *   - E        : initial key\r\n *   - updating : 1 while an EKU exchange is in progress\r\n *   - accepted : 1 after responder accepts a request\r\n *   - Messages: Req, Resp_* (accepted/retry/rejected/clashed), NKU\r\n *\r\n * TLS rules captured (reliable transport):\r\n *   1) Initiator: send Req; wait Resp.\r\n *   2) Responder: on Req, send Resp(accepted) or a rejection.\r\n *   3) If accepted, initiator sends NKU (under OLD keys) and immediately\r\n *      updates SEND keys (send_key := send_key+1).\r\n *   4) Responder on NKU-in: updates RECEIVE keys (receive_key := receive_key+1), sends NKU\r\n *      (under OLD keys), then updates SEND keys (send_key := send_key+1).\r\n *   5) Initiator on responder NKU-in: updates RECEIVE keys (receive_key := receive_key+1).\r\n *\r\n * After success, both peers have send_key==receive_key==E+1 and updating==0.\r\n```",
              "createdAt": "2025-09-10T16:39:50Z",
              "updatedAt": "2025-09-10T16:39:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_Jk9A",
          "commit": {
            "abbreviatedOid": "4371d20"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:40:14Z",
          "updatedAt": "2025-09-10T16:40:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n *\r\n```",
              "createdAt": "2025-09-10T16:40:14Z",
              "updatedAt": "2025-09-10T16:40:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_JltO",
          "commit": {
            "abbreviatedOid": "be2c3fb"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:41:11Z",
          "updatedAt": "2025-09-10T16:41:12Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "```suggestion\r\n    byte send_key = E;      /* send key */\r\n```",
              "createdAt": "2025-09-10T16:41:12Z",
              "updatedAt": "2025-09-10T16:41:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM6_Jl_R",
          "commit": {
            "abbreviatedOid": "3c80bb9"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-10T16:41:37Z",
          "updatedAt": "2025-09-10T16:41:37Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n    byte receive_key = E;   /* receive key */\r\n```",
              "createdAt": "2025-09-10T16:41:37Z",
              "updatedAt": "2025-09-10T16:41:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOMJPqLM6pNkcd",
      "title": "Address comments from WG and nits",
      "url": "https://github.com/tlswg/tls-key-update/pull/58",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-18T06:35:51Z",
      "updatedAt": "2025-10-03T07:25:19Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "dcb5c89c0eb17c60ff37b4ca673eafe5d93e35e0",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-3",
      "headRefOid": "9014101a78e24e628e1c90f152488d735419f8dc",
      "closedAt": "2025-10-03T07:25:19Z",
      "mergedAt": "2025-10-03T07:25:19Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "7946d2d4d8cbdbdd4a3e997267fd4a6823b627a5"
      },
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> the definition does not distinguish between compromise of the application traffic secrets and the long-term secret\r\n\r\nI agree that's actually an important distinction. Could that be clarified in the terminology section?",
          "createdAt": "2025-09-29T22:35:35Z",
          "updatedAt": "2025-09-29T22:35:35Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I added a note to the terminology section in response to Usama's remark.",
          "createdAt": "2025-09-30T16:49:22Z",
          "updatedAt": "2025-09-30T16:49:22Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this PR is ready to go.",
          "createdAt": "2025-09-30T16:49:44Z",
          "updatedAt": "2025-09-30T16:49:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7BJX2g",
          "commit": {
            "abbreviatedOid": "102feca"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-09-18T15:22:17Z",
          "updatedAt": "2025-09-18T15:23:31Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Please revert the numbering. Markdown is supposed to correctly re-number list when every element starts with `1. `",
              "createdAt": "2025-09-18T15:22:17Z",
              "updatedAt": "2025-09-18T15:23:31Z"
            },
            {
              "originalPosition": 105,
              "body": "Why add trailing whitespace? It breaks automation...",
              "createdAt": "2025-09-18T15:23:21Z",
              "updatedAt": "2025-09-18T15:23:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BSxqn",
          "commit": {
            "abbreviatedOid": "102feca"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-19T04:48:00Z",
          "updatedAt": "2025-09-19T04:48:00Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "It was added by mistake, removed it. ",
              "createdAt": "2025-09-19T04:48:00Z",
              "updatedAt": "2025-09-19T04:48:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BSxzS",
          "commit": {
            "abbreviatedOid": "102feca"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-19T04:48:04Z",
          "updatedAt": "2025-09-19T04:48:05Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Fixed. ",
              "createdAt": "2025-09-19T04:48:05Z",
              "updatedAt": "2025-09-19T04:48:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Bsfy4",
          "commit": {
            "abbreviatedOid": "ba569e8"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-21T07:57:54Z",
          "updatedAt": "2025-09-21T07:57:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "`traffic keys` is ambiguous. Specify handshake traffic keys or application traffic keys. ",
              "createdAt": "2025-09-21T07:57:54Z",
              "updatedAt": "2025-09-21T07:57:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BzANf",
          "commit": {
            "abbreviatedOid": "ba569e8"
          },
          "author": "Frosne",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-22T09:22:19Z",
          "updatedAt": "2025-09-22T09:22:19Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Nit: I think \"ensuring post-compromise security\" might be a better wording",
              "createdAt": "2025-09-22T09:22:19Z",
              "updatedAt": "2025-09-22T09:22:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BzDpz",
          "commit": {
            "abbreviatedOid": "ba569e8"
          },
          "author": "Frosne",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-22T09:25:32Z",
          "updatedAt": "2025-09-22T09:25:33Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "nit: maybe \"In such cases, the responder MUST acknowledge receipt of the key_update_request with an ACK and, once sufficient resources become available, retransmit the key_update_response until it is acknowledged by the initiator.\". \r\n\r\nOr does it change the logic? ",
              "createdAt": "2025-09-22T09:25:33Z",
              "updatedAt": "2025-09-22T09:25:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BzYLZ",
          "commit": {
            "abbreviatedOid": "ba569e8"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-22T09:44:11Z",
          "updatedAt": "2025-09-22T09:44:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks, fixed. ",
              "createdAt": "2025-09-22T09:44:11Z",
              "updatedAt": "2025-09-22T09:44:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7BzYoy",
          "commit": {
            "abbreviatedOid": "ba569e8"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-22T09:44:32Z",
          "updatedAt": "2025-09-22T09:44:32Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Proposed text looks to me. ",
              "createdAt": "2025-09-22T09:44:32Z",
              "updatedAt": "2025-09-22T09:44:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7DmqI_",
          "commit": {
            "abbreviatedOid": "d2ee6ac"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "While I am not a fan of the term \"post-compromise security\" since the definition does not distinguish between compromise of the application traffic secrets and the long-term secret I am OK with the changes.",
          "createdAt": "2025-09-29T20:32:24Z",
          "updatedAt": "2025-09-29T20:32:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7D6Mad",
          "commit": {
            "abbreviatedOid": "9014101"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2025-09-30T21:50:31Z",
          "updatedAt": "2025-09-30T21:50:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOMJPqLM6sFlnH",
      "title": "Adjusted referencing",
      "url": "https://github.com/tlswg/tls-key-update/pull/60",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adjusted referencing to more modern style with better readability",
      "createdAt": "2025-10-04T12:09:03Z",
      "updatedAt": "2025-10-06T10:48:01Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "7946d2d4d8cbdbdd4a3e997267fd4a6823b627a5",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "main",
      "headRefOid": "d7a4174f2d95c0dd3c9a750aa667c0f97627560a",
      "closedAt": "2025-10-06T10:48:01Z",
      "mergedAt": "2025-10-06T10:48:01Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "8841fcf2c22f3b6711fc877163da274a9b04b05f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7E7Hi0",
          "commit": {
            "abbreviatedOid": "d7a4174"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-06T10:47:49Z",
          "updatedAt": "2025-10-06T10:47:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOMJPqLM6sFnJx",
      "title": "SSLKEYLOGFILE update",
      "url": "https://github.com/tlswg/tls-key-update/pull/61",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added missing EXPORTER_SECRET_N+1 label and SSLKEYLOGFILE IANA considerations",
      "createdAt": "2025-10-04T12:17:28Z",
      "updatedAt": "2025-10-06T10:51:18Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "8841fcf2c22f3b6711fc877163da274a9b04b05f",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "sslkeylog-update",
      "headRefOid": "8b6443c59a2dd6e8c7fc5db6f2576ca1d28a5965",
      "closedAt": "2025-10-06T10:51:18Z",
      "mergedAt": "2025-10-06T10:51:18Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "e1f4dc5ec641fe1c226ce76d49680c3ad1400557"
      },
      "comments": [
        {
          "author": "Frosne",
          "authorAssociation": "NONE",
          "body": "I'm curious if we should state that \"N represents iteration of Extended Key Update\" in SSLKEYLOGFILE Update section",
          "createdAt": "2025-10-06T09:10:11Z",
          "updatedAt": "2025-10-06T09:10:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7E7IyP",
          "commit": {
            "abbreviatedOid": "bedec61"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-06T10:49:29Z",
          "updatedAt": "2025-10-06T10:49:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOMJPqLM6sP7lH",
      "title": "Update to Security Considerations",
      "url": "https://github.com/tlswg/tls-key-update/pull/62",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-06T11:38:29Z",
      "updatedAt": "2025-10-13T06:54:41Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "e1f4dc5ec641fe1c226ce76d49680c3ad1400557",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-4",
      "headRefOid": "6fac6ccea30b62de0ad8e30a8e0a315d0434ec4a",
      "closedAt": "2025-10-13T06:54:41Z",
      "mergedAt": "2025-10-13T06:54:41Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "c008abf218d356d5df85617e22b284fff1e751ab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7GVbPj",
          "commit": {
            "abbreviatedOid": "8dfaad5"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-11T17:52:41Z",
          "updatedAt": "2025-10-11T17:52:42Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nTo ensure post-compromise security guarantees:\r\n```",
              "createdAt": "2025-10-11T17:52:41Z",
              "updatedAt": "2025-10-11T17:52:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7GVbYk",
          "commit": {
            "abbreviatedOid": "8dfaad5"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-11T17:54:32Z",
          "updatedAt": "2025-10-11T17:54:33Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nThe Extended Key Update mechanism increases computational and state-management overhead. A malicious peer could attempt to exhaust CPU or memory resources by initiating excessive update requests.\r\n```",
              "createdAt": "2025-10-11T17:54:32Z",
              "updatedAt": "2025-10-11T17:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7GVbZ0",
          "commit": {
            "abbreviatedOid": "8dfaad5"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-11T17:54:54Z",
          "updatedAt": "2025-10-11T17:54:54Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n* Limit the frequency of accepted Extended Key Update requests per session.\r\n```",
              "createdAt": "2025-10-11T17:54:54Z",
              "updatedAt": "2025-10-11T17:54:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7GVbwg",
          "commit": {
            "abbreviatedOid": "8dfaad5"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-11T17:56:19Z",
          "updatedAt": "2025-10-11T17:56:20Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nDeployments SHOULD evaluate Extended Key Update performance under load and fault conditions, such as high-frequency or concurrent updates. TLS policies SHOULD define explicit rate limits that balance post-compromise security benefits against potential DoS exposure.\r\n```",
              "createdAt": "2025-10-11T17:56:19Z",
              "updatedAt": "2025-10-11T17:56:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7GVb6j",
          "commit": {
            "abbreviatedOid": "8dfaad5"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I have added a few minor wording improvements but the text is good otherwise.\r\nThanks for the update!",
          "createdAt": "2025-10-11T17:57:00Z",
          "updatedAt": "2025-10-11T17:57:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOMJPqLM6thPwg",
      "title": "Update to the TLS State Machine (Appendix)",
      "url": "https://github.com/tlswg/tls-key-update/pull/63",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is still work in progress.\r\n",
      "createdAt": "2025-10-13T18:44:46Z",
      "updatedAt": "2025-10-19T16:15:34Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "c008abf218d356d5df85617e22b284fff1e751ab",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-6",
      "headRefOid": "847d89cef33887ed03a8d13957f79071edfd6a88",
      "closedAt": "2025-10-19T16:15:31Z",
      "mergedAt": "2025-10-19T16:15:31Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "d7f371a0ea1d8334cfb6a866208a8c3bf1dd4311"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7G_OmS",
          "commit": {
            "abbreviatedOid": "55a56b8"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T05:55:12Z",
          "updatedAt": "2025-10-15T05:55:13Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "```suggestion\r\n- Responder may defer Resp under load (no status reply), then must send it once resources are free.\r\n```",
              "createdAt": "2025-10-15T05:55:12Z",
              "updatedAt": "2025-10-15T05:55:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7G_OsK",
          "commit": {
            "abbreviatedOid": "55a56b8"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-15T05:55:24Z",
          "updatedAt": "2025-10-15T05:55:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOMJPqLM6thsXa",
      "title": "Update to the DTLS State Machine (Appendix)",
      "url": "https://github.com/tlswg/tls-key-update/pull/64",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is still work in progress.",
      "createdAt": "2025-10-13T19:32:51Z",
      "updatedAt": "2025-10-19T16:15:55Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "c008abf218d356d5df85617e22b284fff1e751ab",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "hannestschofenig-patch-7",
      "headRefOid": "af79afcb91dd257b65602be524a35562deabb239",
      "closedAt": "2025-10-19T16:15:52Z",
      "mergedAt": "2025-10-19T16:15:52Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "c2d33b2c102c092e3604ec88d21696df17b69ff5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7HAJnQ",
          "commit": {
            "abbreviatedOid": "1ef8d01"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T07:01:11Z",
          "updatedAt": "2025-10-15T07:01:11Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Appendix is typically for informational purpose only, can it use RFC2119 keywords like \"MUST\" ? ",
              "createdAt": "2025-10-15T07:01:11Z",
              "updatedAt": "2025-10-15T07:01:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7HDH6K",
          "commit": {
            "abbreviatedOid": "1ef8d01"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T09:58:02Z",
          "updatedAt": "2025-10-15T09:58:02Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I can't parse the last line. you may want to say:\r\nApplication data can be transmitted at any time using the sender\u2019s current transmit epoch. A receiver must accept application data if the epoch tag on the DTLS record equals the receiver\u2019s current receive epoch. If the receiver has retention active (retain_old == true), the receiver must also accept DTLS records whose epoch tag equals the remembered previous epoch.\r\n",
              "createdAt": "2025-10-15T09:58:02Z",
              "updatedAt": "2025-10-15T09:58:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7HDI_X",
          "commit": {
            "abbreviatedOid": "1ef8d01"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, update looks good to me. ",
          "createdAt": "2025-10-15T09:59:08Z",
          "updatedAt": "2025-10-15T09:59:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7H8USd",
          "commit": {
            "abbreviatedOid": "561a16c"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T11:07:30Z",
          "updatedAt": "2025-10-19T11:07:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is indeed a mistake.",
              "createdAt": "2025-10-19T11:07:30Z",
              "updatedAt": "2025-10-19T11:07:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H8UUb",
          "commit": {
            "abbreviatedOid": "561a16c"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T11:07:53Z",
          "updatedAt": "2025-10-19T11:07:54Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nCrossed requests. If both peers independently initiate the extended key update and the key_update_request messages cross in flight, compare the KeyShareEntry.key_exchange values. The request with the lower lexicographic value must be ignored. If the values are equal, the endpoint must abort with an \"unexpected_message\" alert. If the peer's value is higher than the local one, the endpoint abandons its in-flight update and processes the peer's request as responder.\r\n```",
              "createdAt": "2025-10-19T11:07:54Z",
              "updatedAt": "2025-10-19T11:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H8t7_",
          "commit": {
            "abbreviatedOid": "1ef8d01"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T16:15:14Z",
          "updatedAt": "2025-10-19T16:15:14Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I updated the text based in your suggestion.",
              "createdAt": "2025-10-19T16:15:14Z",
              "updatedAt": "2025-10-19T16:15:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOMJPqLM6t5Bdq",
      "title": "Address comments from Usama",
      "url": "https://github.com/tlswg/tls-key-update/pull/65",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/tlswg/tls-key-update/issues/59",
      "createdAt": "2025-10-15T13:48:19Z",
      "updatedAt": "2025-10-19T16:16:17Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "c008abf218d356d5df85617e22b284fff1e751ab",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-5",
      "headRefOid": "2cafa9f04980705f6d0d07d5e34dfdfcc0c3d488",
      "closedAt": "2025-10-19T16:16:15Z",
      "mergedAt": "2025-10-19T16:16:15Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "5ce056e84aa10fdf0982738188c36eaca59b05fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7H8Uf9",
          "commit": {
            "abbreviatedOid": "2cafa9f"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am OK with the proposed edits. I was not quite sure why you rename \"master secret\" to \"main secret\" but the change is fine.",
          "createdAt": "2025-10-19T11:10:23Z",
          "updatedAt": "2025-10-19T11:10:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOMJPqLM6uO9v5",
      "title": "Updates to Exporter section",
      "url": "https://github.com/tlswg/tls-key-update/pull/66",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-17T06:07:51Z",
      "updatedAt": "2025-10-24T16:14:49Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "5ce056e84aa10fdf0982738188c36eaca59b05fe",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-6",
      "headRefOid": "4c004ef3ea39204da049dfd6a3eff8a147427447",
      "closedAt": "2025-10-20T11:19:01Z",
      "mergedAt": "2025-10-20T11:19:01Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "e3c5346e5eea6c369f451e692a74b69912ac1f53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7H8UiR",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T11:10:53Z",
          "updatedAt": "2025-10-19T11:10:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nWhen the exporter main secret is updated following a successful Extended Key Update,\r\n```",
              "createdAt": "2025-10-19T11:10:53Z",
              "updatedAt": "2025-10-19T11:10:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H8Ukh",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T11:11:23Z",
          "updatedAt": "2025-10-19T11:11:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Give the other PR that changes the term from \"master\" to \"main\" I was wondering whether we should also change it here.",
              "createdAt": "2025-10-19T11:11:23Z",
              "updatedAt": "2025-10-19T11:11:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H8Uou",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-19T11:12:14Z",
          "updatedAt": "2025-10-19T11:12:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7H8aO_",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T12:15:27Z",
          "updatedAt": "2025-10-19T12:15:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I do not think this would work. What prevents the following:\r\n\r\n1. The sender exports a secret (using old key).\r\n2. The sender sends logical message based on that secret.\r\n3. Extended key update updates the secret in the middle of sending the message.\r\n4. The receiver receives the message, including the EKU.\r\n5. The receiver exports a secret (using new key, since old key is no longer available as there has been data since update!). \r\n6. ... Everything blows up as the exported secrets do not match.",
              "createdAt": "2025-10-19T12:15:27Z",
              "updatedAt": "2025-10-19T12:15:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H8b-B",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T12:36:22Z",
          "updatedAt": "2025-10-19T12:36:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Adding such notification without breaking API change requires the application to explicitly opt-in to this mechanism. Furthermore, I do not think that would even be sufficient. Exporters are neither directional nor synchronized, so the exporter API would have to be changed to add epoch as input.\r\n\r\nThen the key management would be nontrivial: Logical messages can take nontrivial time to send, enough to complete the whole EKU sequence in the middle. Or worse, two of those! Thus, just keeping the previous key is not sufficient, as the required key can be two (or more!) back.\r\n\r\nAnd then what if the EKU happens between exporting the secret and starting to send the logical message? Then one has logical message that is completely sent using the new key, but is still using the old key.",
              "createdAt": "2025-10-19T12:36:22Z",
              "updatedAt": "2025-10-19T12:36:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7H-zVl",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T06:20:33Z",
          "updatedAt": "2025-10-20T06:20:33Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Yes, makes sense to be consistent",
              "createdAt": "2025-10-20T06:20:33Z",
              "updatedAt": "2025-10-20T06:20:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IAE5S",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T08:28:14Z",
          "updatedAt": "2025-10-20T08:28:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Yes, https://datatracker.ietf.org/doc/draft-ietf-tls-rfc8446bis/ uses \"main secret\" instead of \"master secret\". ",
              "createdAt": "2025-10-20T08:28:14Z",
              "updatedAt": "2025-10-20T08:28:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IAPyk",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T08:41:14Z",
          "updatedAt": "2025-10-20T08:41:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The point about exporter synchronization at the API level is understood, but it is an implementation and API consideration rather than a protocol aspect. \r\nAdditionally, aggressive  EKU triggering would represent misbehavior under this specification and would be treated as a DoS, so maintaining more than two generations of exporter secrets is not expected to be necessary.",
              "createdAt": "2025-10-20T08:41:14Z",
              "updatedAt": "2025-10-20T08:43:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IAnfC",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T09:07:04Z",
          "updatedAt": "2025-10-20T09:07:04Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "To support EKU, TLS implementations will have to internally manage the transition between exporter secrets, notify applications when a new exporter secret is active.\r\nThe race condition you described cannot occur in TLS because record delivery is ordered. All records protected with the previous traffic keys are received and processed before the Extended Key Update message that installs the new keying material. Thus, both peers transition exporter secrets in a synchronized manner.\r\n\r\nThe potential overlap only exists for DTLS, which allows out-of-order delivery. The draft already addresses that case by requiring retention of the previous exporter secret until the retention timer expires",
              "createdAt": "2025-10-20T09:07:04Z",
              "updatedAt": "2025-10-20T09:07:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IAvjK",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Just added smaller comments",
          "createdAt": "2025-10-20T09:14:23Z",
          "updatedAt": "2025-10-20T09:16:57Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Proposal to enhance the last sentence to also cover the relation to DTLS.\r\n\r\nAll security considerations of TLS 1.3 {{TLS}} and DTLS.13 {{!DTLS=RFC9147}} continue to apply.",
              "createdAt": "2025-10-20T09:14:23Z",
              "updatedAt": "2025-10-20T09:16:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IChgl",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T11:16:51Z",
          "updatedAt": "2025-10-20T11:16:51Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thanks, fixed.",
              "createdAt": "2025-10-20T11:16:51Z",
              "updatedAt": "2025-10-20T11:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IHvr1",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:18:36Z",
          "updatedAt": "2025-10-20T18:18:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "As the last case (EKU updating exporter secret between export and sending the message) shows, even exporter interface with explicit epoch control together with epoch change notifications is not sufficient. Even in TLS where re-ordering can not happen.\r\n\r\nAnd EKU triggering twice in one logical message is not aggressive if the message is very large.",
              "createdAt": "2025-10-20T18:18:36Z",
              "updatedAt": "2025-10-20T18:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7IH0U5",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-20T18:27:00Z",
          "updatedAt": "2025-10-20T18:27:00Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "That race condition does not depend on any re-ordering (the description did not mention re-ordering or any packet loss) and thus can also happen in TLS. For an even nastier version, have the EKU update the exporter secret between export and sending the message.\r\n\r\nFor the nastier version, the receiver has no way of telling the correct epoch unless explicitly specified by application protocol. Which is not acceptable.",
              "createdAt": "2025-10-20T18:27:00Z",
              "updatedAt": "2025-10-20T18:32:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7JM6rO",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-24T10:22:59Z",
          "updatedAt": "2025-10-24T10:22:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I\u2019m not entirely sure I understand the exact protocol changes you are proposing here. Could you please outline the specific modification you have in mind for the draft ?",
              "createdAt": "2025-10-24T10:22:59Z",
              "updatedAt": "2025-10-24T10:22:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7JM7vi",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-24T10:24:11Z",
          "updatedAt": "2025-10-24T10:24:11Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It would help if you could outline the specific modification you believe should be added, so we can evaluate whether this needs to be addressed in this draft.",
              "createdAt": "2025-10-24T10:24:11Z",
              "updatedAt": "2025-10-24T10:24:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7JU-wG",
          "commit": {
            "abbreviatedOid": "6653a6f"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-24T16:14:49Z",
          "updatedAt": "2025-10-24T16:14:49Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I can not give specific modifications, because I am not sure what I have in mind actually works (this is something so complex that one would need to formally model it to know what could possibly go wrong). I only know what does not work.\r\n\r\nFirstly, this can not work with the present TLS exporter interface, because the exporter is not directional, and it is impossible to synchronize updates in the general case (and even special cases are far beyond what TLS can do). One would have define new TLS exporter interface with epoch as explicit input in order to get around this problem.\r\n\r\nSecondly, epoch change notifications (even if local and remote) are not sufficient, because the epoch can change between application using exporter and transmitting the data, leading to receiver inferring incorrect epoch. One would have to define some interface allowing application to freeze epoch updates.\r\n\r\nThese two problems are independent of any re-ordering or packet loss, so can happen with TLS, not just DTLS.\r\n\r\nThen there might be a third problem I am not thinking of... Or there might be a problem with the solution given to the second problem that only appears in DTLS, which allows re-ordering or packet loss.\r\n\r\nAnd even if this could be made to work, the interface changes are quite high cost to any application that uses TLS exporters.",
              "createdAt": "2025-10-24T16:14:49Z",
              "updatedAt": "2025-10-24T16:14:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOMJPqLM6vX53w",
      "title": "Editorial: remove duplicate sections and fix appendix formatting",
      "url": "https://github.com/tlswg/tls-key-update/pull/68",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-23T21:51:41Z",
      "updatedAt": "2025-10-24T05:22:57Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "e3c5346e5eea6c369f451e692a74b69912ac1f53",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "remove-duplicate",
      "headRefOid": "0b45422fa2785d3456974b2cc33615a385403a15",
      "closedAt": "2025-10-24T05:22:57Z",
      "mergedAt": "2025-10-24T05:22:57Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "94724f5b71ed76a6ea5ba107bb457007b32fb708"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7JJHtJ",
          "commit": {
            "abbreviatedOid": "0b45422"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks Usama for fixing these issues. ",
          "createdAt": "2025-10-24T05:22:51Z",
          "updatedAt": "2025-10-24T05:22:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOMJPqLM6vuKIe",
      "title": "Address comments from Usama",
      "url": "https://github.com/tlswg/tls-key-update/pull/73",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It addresses https://github.com/tlswg/tls-key-update/issues/69 and https://github.com/tlswg/tls-key-update/issues/70",
      "createdAt": "2025-10-26T08:26:30Z",
      "updatedAt": "2025-10-28T21:19:29Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "94724f5b71ed76a6ea5ba107bb457007b32fb708",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-5",
      "headRefOid": "43c9c766dd7b0c7d2a31243867cd8a63754fce5d",
      "closedAt": "2025-10-28T09:49:10Z",
      "mergedAt": "2025-10-28T09:49:10Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "a1dd84b433dbd86b43be325a958cbe6ea6bc22ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7J6wsX",
          "commit": {
            "abbreviatedOid": "43c9c76"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for addressing feedback from Usama. The text looks good to me.",
          "createdAt": "2025-10-28T09:25:51Z",
          "updatedAt": "2025-10-28T09:25:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7KGz58",
          "commit": {
            "abbreviatedOid": "43c9c76"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Please give the exact names of the keys. ",
          "createdAt": "2025-10-28T21:02:25Z",
          "updatedAt": "2025-10-28T21:19:29Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Why don't you say exactly what it is according to RFC8446bis? Did you mean `client_write_key` and `server_write_key` for application data?",
              "createdAt": "2025-10-28T21:02:26Z",
              "updatedAt": "2025-10-28T21:19:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOMJPqLM6wh7n6",
      "title": "Address issues",
      "url": "https://github.com/tlswg/tls-key-update/pull/80",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-30T05:28:10Z",
      "updatedAt": "2025-11-01T07:06:18Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "a1dd84b433dbd86b43be325a958cbe6ea6bc22ee",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-7",
      "headRefOid": "d6a69b1aed2effd22b20946de7452195fe175b0c",
      "closedAt": "2025-11-01T07:06:18Z",
      "mergedAt": "2025-11-01T07:06:18Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "f7708786157cb835f5ae4ab1e10d883f40768e8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7Kr9-y",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the PR, Tiru. These changes implement the suggestions made by Ekr regarding the labels in the key derivation functions. I agree that those are useful.",
          "createdAt": "2025-10-30T16:23:01Z",
          "updatedAt": "2025-10-30T16:23:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7KucEs",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-30T18:53:23Z",
          "updatedAt": "2025-10-30T18:53:23Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I think post-compromise security breaks if adversary gets both current application traffic keys (which are keys most at risk of compromise, because older keys tend to get overwritten). MITM adversary can use the keys to initiate EKU with both peers, and then compute the resulting application traffic keys. The keys will not match, but adversary is able to re-encrypt the traffic. Furthermore, EKU can not restore security because adversary can re-write the shares, like how one does MITM on unauthenticated Diffie-Hellman.\r\n\r\nI think signing the server share (client may or may not have signing key, the server always does) with nonce would prevent that. I think one would have to rely on key continuity from handshake, as certificate update is famously nasty problem (which is the reason HTTP/2 bans re-negotiation).\r\n\r\nAnd \"once the compromise is resolved\": What would resolve the compromise within lifetime of the connection? \r\n\r\n* Compromises due to one-off operational errors seem unlikely to compromise such keys.\r\n* It is unlikely to be able to fix transient compromises (like bleeding) so those are likely repeatable.\r\n* Rich operating system compromises are unlikely to be transient.\r\n",
              "createdAt": "2025-10-30T18:53:23Z",
              "updatedAt": "2025-10-30T20:01:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7KukNO",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "ctz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-30T19:02:34Z",
          "updatedAt": "2025-10-30T19:02:34Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I'm afraid this entire paragraph doth butter no parsnips.\n\n- no long-term private keys are used in this entire scheme, so they cannot contribute to achieving post-compromise security?\n- if the application traffic keys are compromised, then using them further to repair the connection with a key exchange whose authenticity is hooked off compromised keys, is ineffective.\n\nMaybe this is addressing a very narrow model, where the keys are compromised but the adversary promises not to use them? If so, this text should be saying that.\n\n",
              "createdAt": "2025-10-30T19:02:34Z",
              "updatedAt": "2025-10-30T19:02:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7KvkTB",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-30T20:15:02Z",
          "updatedAt": "2025-10-30T20:15:02Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "The coherent adversary models where EKU would help (adversary getting some old keys) seem much less likely than ones where it would not help (bleeding, RCE or zombification of TLS endpoint).",
              "createdAt": "2025-10-30T20:15:02Z",
              "updatedAt": "2025-10-30T20:15:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K4wx5",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-31T11:39:39Z",
          "updatedAt": "2025-10-31T11:39:40Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I updated the text for better clarity. ",
              "createdAt": "2025-10-31T11:39:39Z",
              "updatedAt": "2025-10-31T11:39:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K4178",
          "commit": {
            "abbreviatedOid": "9cbbc70"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-31T11:45:25Z",
          "updatedAt": "2025-10-31T11:45:25Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Updated text to discuss MiTM.  Examples of short-term compromise include short-lived exposures such as a memory snapshot, temporary local misconfiguration, recovery of outdated session keys from backups, or brief side-channel leakage, cases where an attacker obtains key material momentarily but lacks ongoing access to the endpoint.",
              "createdAt": "2025-10-31T11:45:25Z",
              "updatedAt": "2025-10-31T11:45:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K7EPX",
          "commit": {
            "abbreviatedOid": "d6a69b1"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The changes are fine with me. Thank you for the PR Tiru, this clearly describes the limits. I agree, additional measures may be necessary to ensure MiTM attacks are detected during the EKU periods. We could raise this as question in IETF124 on the slides but underline the smaller time window, in which this may happen. ",
          "createdAt": "2025-10-31T14:10:21Z",
          "updatedAt": "2025-10-31T14:10:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOMJPqLM6wiqHx",
      "title": "Update to Exporter section",
      "url": "https://github.com/tlswg/tls-key-update/pull/81",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-30T07:10:19Z",
      "updatedAt": "2025-11-02T07:44:01Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "a1dd84b433dbd86b43be325a958cbe6ea6bc22ee",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-8",
      "headRefOid": "798710df9e0fea8865f8a05a77dbbdd9c76f62a9",
      "closedAt": "2025-11-02T06:31:28Z",
      "mergedAt": "2025-11-02T06:31:28Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "f45a0c7c288028ba47e1ed44ce39eb7148f93219"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7KsJPc",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree that the text demanding a new API that informs the application of the new exporter secret is necessary.",
          "createdAt": "2025-10-30T16:30:14Z",
          "updatedAt": "2025-10-30T16:30:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7Kuw8p",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-30T19:17:20Z",
          "updatedAt": "2025-10-30T19:17:20Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This seems a bit unclear. Is this proposing that TLS libraries keep some `(label,context)` pairs and send the resulting updated exporter value to the application?\r\n\r\nEncryption keys is just one half of utility of TLS exporters: The exporters are also used for authentication nonces, and sometimes predicting future queries is not possible (e.g., Concealed HTTP authentication).\r\n\r\nAnd I do not think think this ensures synchronization even for encryption keys. Any such encryption keys are used on separate logical connection (the (D)TLS connection is already encrypted!) and there is nothing to prevent packets from that connection from overtaking ones from (D)TLS connection. This can result in application receiving packets from new epoch before it can derive the correct encryption keys. This is especially bad if the application connection is over reliable transport (like TCP).",
              "createdAt": "2025-10-30T19:17:20Z",
              "updatedAt": "2025-10-30T19:17:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7KvIas",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-30T19:43:21Z",
          "updatedAt": "2025-10-30T19:43:21Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "For DTLS, processing out-of-order packets is not sufficient for applications that have some reliable application-level message that uses exporters. Even without re-ordering, just packet loss, such message can arrive well after epoch transition, possibly without any signs that such message is coming until it arrives.\r\n\r\nWorse, since the message must be associated with correct epoch at DTLS level, it is never safe to free the epoch. And since there are only two epoch signaling bits in DTLS 1.3, once the fourth EKU happens, things go south.\r\n\r\nThis problem does not exist in base DTLS 1.3, since there is never need to associate message with epoch, so re-sending a message can freely use the newest epoch.\r\n",
              "createdAt": "2025-10-30T19:43:21Z",
              "updatedAt": "2025-10-30T19:43:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K5K4N",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-31T12:13:05Z",
          "updatedAt": "2025-10-31T12:13:05Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "> This seems a bit unclear. Is this proposing that TLS libraries keep some `(label,context)` pairs and send the resulting updated exporter value to the application?\r\n\r\nFixed text as follows:\r\n* The corresponding EKM can be derived by the application using the \r\n  exporter construction defined above, with its chosen label and context value \r\n  as inputs, as specified in {{Section 4 of !RFC5705}}.\r\n> \r\n> Encryption keys is just one half of utility of TLS exporters: The exporters are also used for authentication nonces, and sometimes predicting future queries is not possible (e.g., Concealed HTTP authentication).\r\n\r\nI\u2019m aware of several applications that use exporters for key derivation (DTLS-SRTP, DTLS-SRTP, but I haven\u2019t seen a specification that defines their use for authentication nonces. Could you please provide a RFC where exporters are used that way ?\r\n\r\n> \r\n> And I do not think think this ensures synchronization even for encryption keys. Any such encryption keys are used on separate logical connection (the (D)TLS connection is already encrypted!) and there is nothing to prevent packets from that connection from overtaking ones from (D)TLS connection. This can result in application receiving packets from new epoch before it can derive the correct encryption keys. This is especially bad if the application connection is over reliable transport (like TCP).\r\n\r\nCould you please illustrate the desynchronization issue you\u2019re referring to using DTLS-SRTP as an example?\r\nMy understanding is that the replay-window and key-retention rules in {{!RFC3711}}, together with the DTLS ACK, should prevent a receiver from seeing SRTP packets encrypted with the new exporter secret before it has derived the corresponding keys.\r\n\r\n",
              "createdAt": "2025-10-31T12:13:05Z",
              "updatedAt": "2025-10-31T12:13:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K6drj",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-31T13:35:37Z",
          "updatedAt": "2025-10-31T13:35:38Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "> I\u2019m aware of several applications that use exporters for key derivation (DTLS-SRTP, DTLS-SRTP, but I haven\u2019t seen a specification that defines their use for authentication nonces. Could you please provide a RFC where exporters are used that way ?\r\n\r\nThe concealed HTTP authentication is RFC 9729. Note that exporter contexts are unpredictable due to those being constructed from the HTTP request.\r\n \r\n> > And I do not think think this ensures synchronization even for encryption keys. Any such encryption keys are used on separate logical connection (the (D)TLS connection is already encrypted!) and there is nothing to prevent packets from that connection from overtaking ones from (D)TLS connection. This can result in application receiving packets from new epoch before it can derive the correct encryption keys. This is especially bad if the application connection is over reliable transport (like TCP).\r\n> \r\n> Could you please illustrate the desynchronization issue you\u2019re referring to using DTLS-SRTP as an example? My understanding is that the replay-window and key-retention rules in {{!RFC3711}}, together with the DTLS ACK, should prevent a receiver from seeing SRTP packets encrypted with the new exporter secret before it has derived the corresponding keys.\r\n\r\nPacket loss in DTLS is especially easy way to have this happen, as it tends to give lots of head-start:\r\n\r\nHave sender send three packets: First is whatever triggers exporter update (which gets lost), the second is application data with new keys, and the third is re-send of the first.\r\n\r\nNow the receiver receives these in order: The first is application data that uses new keys, and the second triggers exporter update. The first packet obviously can not be decrypted without buffering to wait for the second packet.\r\n\r\nIf application is using unreliable transport, losing those packets is acceptable. However, this is not an option if the application is using reliable transport.\r\n\r\nThere are also variants that do not involve packet loss.",
              "createdAt": "2025-10-31T13:35:37Z",
              "updatedAt": "2025-10-31T13:41:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7K68b4",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-31T14:02:20Z",
          "updatedAt": "2025-10-31T14:02:20Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "> > I\u2019m aware of several applications that use exporters for key derivation (DTLS-SRTP, DTLS-SRTP, but I haven\u2019t seen a specification that defines their use for authentication nonces. Could you please provide a RFC where exporters are used that way ?\r\n> \r\n> The concealed HTTP authentication is RFC 9729. Note that exporter contexts are unpredictable due to those being constructed from the HTTP request.\r\n\r\nThanks, updated text. \r\n\r\n> \r\n> > > And I do not think think this ensures synchronization even for encryption keys. Any such encryption keys are used on separate logical connection (the (D)TLS connection is already encrypted!) and there is nothing to prevent packets from that connection from overtaking ones from (D)TLS connection. This can result in application receiving packets from new epoch before it can derive the correct encryption keys. This is especially bad if the application connection is over reliable transport (like TCP).\r\n> > \r\n> > \r\n> > Could you please illustrate the desynchronization issue you\u2019re referring to using DTLS-SRTP as an example? My understanding is that the replay-window and key-retention rules in {{!RFC3711}}, together with the DTLS ACK, should prevent a receiver from seeing SRTP packets encrypted with the new exporter secret before it has derived the corresponding keys.\r\n> \r\n> Packet loss in DTLS is especially easy way to have this happen, as it tends to give lots of head-start:\r\n> \r\n> Have sender send three packets: First is whatever triggers exporter update (which gets lost), the second is application data with new keys, and the third is re-send of the first.\r\n> \r\n> Now the receiver receives these in order: The first is application data that uses new keys, and the second triggers exporter update. The first packet obviously can not be decrypted without buffering to wait for the second packet.\r\n> \r\n> If application is using unreliable transport, losing those packets is acceptable. However, this is not an option if the application is using reliable transport.\r\n> \r\n> There are also variants that do not involve packet loss.\r\n\r\nIn the Extended Key Update procedure for DTLS, both peers update their send and receive keys only after the final ACK is processed. This prevents either side from sending application data encrypted under the new exporter secret until both have confirmed synchronization. ",
              "createdAt": "2025-10-31T14:02:20Z",
              "updatedAt": "2025-10-31T14:02:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LEeMF",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-01T08:06:35Z",
          "updatedAt": "2025-11-01T08:06:36Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "DTLS 1.3 does not limit epochs to two bits, see https://datatracker.ietf.org/doc/rfc9147/. \r\n\r\nIn DTLS-SRTP, SRTP packets are sent directly over RTP, not within DTLS. The exporter is used only to derive SRTP master keys, and replay-window handling in SRTP ensures correct processing of out-of-order packets.\r\n\r\nDTLS-over-SCTP provides reliable, in-order delivery of DTLS records, so Extended Key Update and its ACKs are always processed before any data encrypted with the new epoch. This eliminates the synchronization issue in that context as well.\r\n",
              "createdAt": "2025-11-01T08:06:36Z",
              "updatedAt": "2025-11-01T08:06:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LHEXR",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-01T18:20:06Z",
          "updatedAt": "2025-11-01T18:20:06Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "While DTLS 1.3 allows 2^64 epochs (or considerably less due to not allowing message sequence number wraparound), there are only two signaling bits for epoch (RFC 9147, section 4).\r\n\r\nNot correct about either application:\r\n\r\n- DTLS-SRTP explicitly supports re-keying active RTP connection, which is distinct from any replay-window handling.\r\n- DTLS-over-SCTP neither provides reliable nor in-order delivery of DTLS records (only control records are reliable-in-order). However, it never exports encryption keys, so DTLS can sequence key updates and data.\r\n  - The latest draft recommends updating authentication keys on EKU. The way it is specified seems to be very hand-wavy, and probably does not work.\r\n\r\nAnd then there are N+1 other applications that use DTLS. Will those work even with both endpoints updated (no way this can be deployed without veto-by-default)?",
              "createdAt": "2025-11-01T18:20:06Z",
              "updatedAt": "2025-11-01T18:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LJKzL",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-02T06:31:21Z",
          "updatedAt": "2025-11-02T06:31:21Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I don\u2019t agree with your interpretation, but to save everyone\u2019s time, could you please propose specific text that you think would address your concerns?\r\nThat way, we can review it directly and see whether it aligns with the intent of the draft.",
              "createdAt": "2025-11-02T06:31:21Z",
              "updatedAt": "2025-11-02T06:31:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LJWfN",
          "commit": {
            "abbreviatedOid": "e76c153"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-02T07:44:01Z",
          "updatedAt": "2025-11-02T07:44:01Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Came up with something that I think would work:\r\n\r\n- Add another exporter interface that takes epoch, label and context as parameters.\r\n  - This is meant for applications that can re-key the application connection, and its use is subject to application-level negotiation. It may or may not require application protocol changes (negotiated by the very same mechanism) to actually use.\r\n  - The existing exporter interface is left alone, functioning like it does without EKU (keys are never updated).\r\n  - Presumably has its own key \"rail\", so produces different results from the existing exporter even in the first epoch.\r\n- Compute new epoch upon sending/receiving the second (response) message.\r\n- Notify application when both peers can compute the new epoch. This happens upon receiving the second or the third (the first ACK) message (which is actually earlier than re-keying TLS).\r\n  - However, there is a subtle pitfall here: Ordering is only guaranteed relative to new epoch computation, not new epoch notification! So applications receiving data from unknown epoch need to attempt new key computation anyway.\r\n",
              "createdAt": "2025-11-02T07:44:01Z",
              "updatedAt": "2025-11-02T07:44:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOMJPqLM6xLdrd",
      "title": "Address comments from Ilari",
      "url": "https://github.com/tlswg/tls-key-update/pull/82",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-03T12:36:47Z",
      "updatedAt": "2025-11-09T06:22:33Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f45a0c7c288028ba47e1ed44ce39eb7148f93219",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-9",
      "headRefOid": "f9f9c59e11305d1f0ab21926cde275e55c6bb55e",
      "closedAt": "2025-11-09T06:22:32Z",
      "mergedAt": "2025-11-09T06:22:32Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "8171e6bd8d29a14987624e232ac1ab0e2db3082a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7LXJxV",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T16:21:02Z",
          "updatedAt": "2025-11-03T16:21:02Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This seems really misleading:\r\n\r\n- \"for DTLS\". This interface is not DTLS-specific, it also works with TLS. This is needed for applications that use TLS for control link and UDP for data link.\r\n- \"DTLS exporter interface\". This is a new interface, not the existing TLS exporter interface. That interface is not specified: What functions/methods does the interface have, what are the argument and return types, and what do those functions do?\r\n  - The original proposal had something like export_epoch, which takes epoch (64-bit integer), label (byte string) and context (byte string) and length (positive integer) and outputs byte string.\r\n  - It would work similarly to existing exporter, but instead of using `exporter_secret`, it would use `exporter_secret_<epoch>` instead.\r\n- It is unspecified when exactly epoch becomes available for export, and when exactly asynchronous notification is triggered. This is critical for interoperability.\r\n  - The original proposal had epoch become available upon send/receive of key_update_response, and notification triggered upon receive of key_update_response or the first new_key_update. Note that it is crucial to confirm that peer has the new epoch available before notifying the application.\r\n\r\nThen while writing this, I noticed that it is also unclear how the EKU key schedule connects to the main TLS key schedule. I guess Main Secret 0 is the same as TLS Main Secret (and exporter_secret_0 would be the same as exporter_secret). And noted that instead of having to steal both active application traffic keys for catastrophic compromise, it suffices to steal just the active main secret (which now has to be kept in memory, and thus vulnerable to compromise).\r\n\r\nAlso, the messages do not seem to be hashed before being fed to key schedule, which results shares being hashed **four** times, which gets painful with post-quantum stuff. And the reasoning mentions `MAL-BIND-K-CT` security, any of the `MAL-*` models are completely irrelevant to TLS.",
              "createdAt": "2025-11-03T16:21:02Z",
              "updatedAt": "2025-11-03T16:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LXK-9",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T16:22:24Z",
          "updatedAt": "2025-11-03T16:22:24Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "The existing exporter interface remains unchanged **regardless** if connection uses Extended Key Update or not. Otherwise existing protocols could not enable Extended Key Update at all.",
              "createdAt": "2025-11-03T16:22:24Z",
              "updatedAt": "2025-11-03T16:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LXruM",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-03T16:50:48Z",
          "updatedAt": "2025-11-03T16:50:48Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The decryption might not explicitly fail. The packet could have explicit indication of newer epoch.",
              "createdAt": "2025-11-03T16:50:48Z",
              "updatedAt": "2025-11-03T16:50:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LgGSS",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T06:03:14Z",
          "updatedAt": "2025-11-04T06:03:14Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Good point, updated text. ",
              "createdAt": "2025-11-04T06:03:14Z",
              "updatedAt": "2025-11-04T06:03:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LgGcS",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T06:03:29Z",
          "updatedAt": "2025-11-04T06:03:29Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Thanks, fixed. ",
              "createdAt": "2025-11-04T06:03:29Z",
              "updatedAt": "2025-11-04T06:03:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LgMJc",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T06:14:24Z",
          "updatedAt": "2025-11-04T06:14:24Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I updated the text, please check. please clarify which original proposal you are referring to.\r\nI will raise a separate issue for the other comments.",
              "createdAt": "2025-11-04T06:14:24Z",
              "updatedAt": "2025-11-04T06:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Lhd1p",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T08:02:58Z",
          "updatedAt": "2025-11-04T08:02:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This is not acceptable (massive breaking change to TLS). The exporter interface defined in Section 7.5 of TLS **MUST NOT** update its epoch during connection lifetime. Using current epoch would totally break most applications using exporters.\r\n\r\nThe \"additional exporter interface\" is the only way way to export keying material that is updated during connection lifetime. Furthermore, that interface does not have any implicit epoch behavior either, taking the epoch to use as parameter.\r\n\r\n\r\n",
              "createdAt": "2025-11-04T08:02:58Z",
              "updatedAt": "2025-11-04T08:02:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Lhvd5",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T08:14:50Z",
          "updatedAt": "2025-11-04T08:14:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This is racy. In order to prevent race conditions, the notification must be delivered only after both sides have activated the new epoch for epoch-aware export. This implies that the new epoch must be activated before the EKU exchange actually completes.\r\n\r\nIt is critical for interoperability that both sides agree exactly when the new epoch is activated, and exactly when the new epoch is notified.\r\n\r\n",
              "createdAt": "2025-11-04T08:14:50Z",
              "updatedAt": "2025-11-04T08:14:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Lh3oT",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T08:19:58Z",
          "updatedAt": "2025-11-04T08:19:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Fixed text\r\n",
              "createdAt": "2025-11-04T08:19:58Z",
              "updatedAt": "2025-11-04T08:19:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Lh4HQ",
          "commit": {
            "abbreviatedOid": "b917471"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T08:20:16Z",
          "updatedAt": "2025-11-04T08:20:16Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "The proposal I was referring to is https://github.com/tlswg/tls-key-update/pull/81#discussion_r2484287673",
              "createdAt": "2025-11-04T08:20:16Z",
              "updatedAt": "2025-11-04T08:20:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Lh63A",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T08:21:37Z",
          "updatedAt": "2025-11-04T08:21:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It is already discussed in DTLS 1.3 Considerations section. ",
              "createdAt": "2025-11-04T08:21:37Z",
              "updatedAt": "2025-11-04T08:21:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7LnXID",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-04T12:04:26Z",
          "updatedAt": "2025-11-04T12:04:26Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This is not specific to DTLS, it also applies to TLS. E.g., an application that uses TLS to key data over UDP (TLS is much better supported than DTLS). And since the rules are presumably the same for both, the final ACK can not trigger anything (since TLS does not have that).\r\n\r\nAnd reading the DTLS 1.3 considerations section, it is not clear when the notification is dispatched, and there does not seem to be any requirement to do the exporter key derivation as early as possible.",
              "createdAt": "2025-11-04T12:04:26Z",
              "updatedAt": "2025-11-04T12:04:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7L2svf",
          "commit": {
            "abbreviatedOid": "e7afee6"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T06:22:51Z",
          "updatedAt": "2025-11-05T06:22:51Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fixed, please check. ",
              "createdAt": "2025-11-05T06:22:51Z",
              "updatedAt": "2025-11-05T06:22:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Mzh-L",
          "commit": {
            "abbreviatedOid": "f9f9c59"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good to me. ",
          "createdAt": "2025-11-07T19:52:55Z",
          "updatedAt": "2025-11-07T19:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOMJPqLM6xnFUX",
      "title": "Update terminology regarding long term secrets",
      "url": "https://github.com/tlswg/tls-key-update/pull/85",
      "state": "MERGED",
      "author": "stfries",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hannestschofenig",
        "yaroslavros",
        "tireddy2",
        "stfries"
      ],
      "labels": [],
      "body": "Updated terminology of long-term secrets to directly relate to the TLS main secret to avoid confusion with long-term keys, which refers certificates and corresponding private keys",
      "createdAt": "2025-11-05T10:14:49Z",
      "updatedAt": "2025-11-06T10:59:02Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "f45a0c7c288028ba47e1ed44ce39eb7148f93219",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "stfries-patch-2-terminology",
      "headRefOid": "1b99eeb34b3212024b9a662b999588dd49c166f7",
      "closedAt": "2025-11-06T10:59:02Z",
      "mergedAt": "2025-11-06T10:59:02Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "51f891ac2b8c02f07f3df0cfe27d0ea8321a972c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7L9L4m",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T12:52:33Z",
          "updatedAt": "2025-11-05T12:52:33Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nwhere the TLS main secret is extracted once and reused, poses a greater long-term\r\n```",
              "createdAt": "2025-11-05T12:52:33Z",
              "updatedAt": "2025-11-05T12:53:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7L9P8b",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T12:55:32Z",
          "updatedAt": "2025-11-05T12:55:32Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "TLS main secret is anyway deleted after traffic keys are generated. I would say private key with a corresponding certificate. ",
              "createdAt": "2025-11-05T12:55:32Z",
              "updatedAt": "2025-11-05T12:55:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7L9SNy",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "we should not refer to TLS main secret as long-term secret. ",
          "createdAt": "2025-11-05T12:57:07Z",
          "updatedAt": "2025-11-05T12:57:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7MDJcC",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-05T17:08:40Z",
          "updatedAt": "2025-11-05T17:08:40Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Would be fine for me to avoid the long term secret term completely and only refer to the TLS main secret. ",
              "createdAt": "2025-11-05T17:08:40Z",
              "updatedAt": "2025-11-05T17:08:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MNjvo",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T04:58:33Z",
          "updatedAt": "2025-11-06T04:58:34Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I suggest to remove this line, private key is discussed in Security considerations section. We cannot assume TLS main secret is not compromised.",
              "createdAt": "2025-11-06T04:58:33Z",
              "updatedAt": "2025-11-06T04:58:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MO54n",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T06:40:45Z",
          "updatedAt": "2025-11-06T06:40:45Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Yes, this is true, we may not refer to both (privat key and TLS main secret). I propose to leave the first half to state the assumptions in the abstract directly, which would result in:\r\n\"We assume that an adversary may obtain access to the application traffic secrets.\"",
              "createdAt": "2025-11-06T06:40:45Z",
              "updatedAt": "2025-11-06T06:58:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MPKF4",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T07:01:54Z",
          "updatedAt": "2025-11-06T07:01:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "included as proposed.",
              "createdAt": "2025-11-06T07:01:54Z",
              "updatedAt": "2025-11-06T07:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MQ2Qe",
          "commit": {
            "abbreviatedOid": "c9c9bff"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T08:52:30Z",
          "updatedAt": "2025-11-06T08:52:31Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Yes, works for me. ",
              "createdAt": "2025-11-06T08:52:31Z",
              "updatedAt": "2025-11-06T08:52:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MSpet",
          "commit": {
            "abbreviatedOid": "384a197"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-06T10:33:23Z",
          "updatedAt": "2025-11-06T10:33:23Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "incorporated as discussed",
              "createdAt": "2025-11-06T10:33:23Z",
              "updatedAt": "2025-11-06T10:33:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7MTH6o",
          "commit": {
            "abbreviatedOid": "1b99eeb"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-11-06T10:58:51Z",
          "updatedAt": "2025-11-06T10:58:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOMJPqLM6x6Ckx",
      "title": "Update to PCS",
      "url": "https://github.com/tlswg/tls-key-update/pull/86",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-06T13:58:56Z",
      "updatedAt": "2025-11-11T07:08:38Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "8171e6bd8d29a14987624e232ac1ab0e2db3082a",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-10",
      "headRefOid": "0f935b9d90e6d3720ecc763c1c4909be85e6fc90",
      "closedAt": "2025-11-09T06:27:47Z",
      "mergedAt": "2025-11-09T06:27:46Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "09dc70a5edfd652cfa77e7edef6ba63085b0590b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7M0cDy",
          "commit": {
            "abbreviatedOid": "a4489fc"
          },
          "author": "stfries",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good to me. Thanks for the updates. ",
          "createdAt": "2025-11-07T20:42:41Z",
          "updatedAt": "2025-11-07T20:42:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7NDV0S",
          "commit": {
            "abbreviatedOid": "0f935b9"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-09T17:44:04Z",
          "updatedAt": "2025-11-09T17:44:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This seems woefully under-specified. How exactly is the hash incorporated into the calculation? Where in \"authenticator transcript\" is the hash added? Is it wrapped in message_hash type (like the hashed Client Hello from base TLS 1.3)? Are all EKU exchanges included, or is just the most recent one? What about the finished transcript (note RFC9261 is designed so that the hash can be multi-tapped).\r\n\r\nMore serious problem is that there is nothing to prevent EKU from racing with exporter authenticator, leading to receiver using different EKU transcript from sender. Which causes EA that should work being rejected (which might cause fatal application error).\r\n\r\nHowever, again it is possible to do something clever: Instead of using the RFC9261 construction with normal TLS exporter interface for exported authenticators, use RFC9261 construction with epoch-aware TLS exporter, and send the correct epoch along with the exported authenticator.This requires application protocol changes, but those seem necessary anyway.",
              "createdAt": "2025-11-09T17:44:04Z",
              "updatedAt": "2025-11-09T17:44:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NbjWT",
          "commit": {
            "abbreviatedOid": "0f935b9"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T07:08:38Z",
          "updatedAt": "2025-11-11T07:08:38Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Thanks @ilaril for the feedback, I will raise a seperate issue and PR to address this issue. ",
              "createdAt": "2025-11-11T07:08:38Z",
              "updatedAt": "2025-11-11T07:08:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOMJPqLM6yp6D1",
      "title": "Eliminate unnecessary message",
      "url": "https://github.com/tlswg/tls-key-update/pull/87",
      "state": "MERGED",
      "author": "yaroslavros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF124 I have tightened up the process and eliminated 1 unnecessary message in both TLS and DTLS flows.\r\n\r\nPlease check.",
      "createdAt": "2025-11-11T01:44:25Z",
      "updatedAt": "2026-01-06T18:30:41Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "d2db856fa748537bed423cc6418b3aefb8f13a00",
      "headRepository": "yaroslavros/tls-key-update",
      "headRefName": "main",
      "headRefOid": "a093f1f91c1476ee83feafb764fc6962e31261f5",
      "closedAt": "2026-01-06T18:30:40Z",
      "mergedAt": "2026-01-06T18:30:40Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "81592c444f955fe1494154f0893325d8fa441a08"
      },
      "comments": [
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I am still not convinced about this optimization. The initial design was selected to separate the two phases - first phase is to exchange the DH public keys and the second phase is to activate the keys. Our use cases, long-lived connections in telco networks and in the industurial IoT sector, do not have any performance constraints.\r\n\r\nMaking this change will also requires us to re-do the formal analysis.",
          "createdAt": "2025-11-12T14:52:05Z",
          "updatedAt": "2025-11-12T14:52:05Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "It also seems like this prevents the initiator from delaying the update in TLS (due to unexpected overload) without stalling the entire channel, as the responder will immediately change the keys it uses after sending key_update_response. Delaying the update still works in DTLS, as the initiator can explicitly ACK the response, which does not trigger any actions from the responder.",
          "createdAt": "2025-11-12T15:35:22Z",
          "updatedAt": "2025-11-12T15:35:22Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Ilari on his last point. If we accept this PR we have to add extra text to address the case of delayed updates in TLS.\r\n\r\nOtherwise the proposed changes work fine in the SPIN model. ",
          "createdAt": "2026-01-05T09:20:25Z",
          "updatedAt": "2026-01-05T09:20:25Z"
        },
        {
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "body": "Added text prohibiting initiator from deferring key derivation in both TLS and DTLS.",
          "createdAt": "2026-01-06T16:32:36Z",
          "updatedAt": "2026-01-06T16:32:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7Ncf6e",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T08:23:57Z",
          "updatedAt": "2025-11-11T08:23:57Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think receive keys should be updated in previous step \u2014 since responder updates its send keys upon sending NKRes, the initiator should update its receive keys after receiving NKRes.",
              "createdAt": "2025-11-11T08:23:57Z",
              "updatedAt": "2025-11-11T08:34:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NcrM8",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T08:34:21Z",
          "updatedAt": "2025-11-11T08:34:22Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "How could responder accept any messages with new key before receiving NKU?\r\n\r\nHowever, because NKRes and NKU both update keys, endpoints must both check those messages are the last in record \u2014 Similarly to the finished message. \r\n",
              "createdAt": "2025-11-11T08:34:21Z",
              "updatedAt": "2025-11-11T08:34:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NcubO",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T08:37:36Z",
          "updatedAt": "2025-11-11T08:37:37Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "As in previous prose, I think it should be \"Client derives new secrets and updates RECEIVE keys here\" and \"Client updates SEND keys here\".",
              "createdAt": "2025-11-11T08:37:36Z",
              "updatedAt": "2025-11-11T08:37:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NdJ24",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T09:02:23Z",
          "updatedAt": "2025-11-11T09:02:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Updated the text",
              "createdAt": "2025-11-11T09:02:23Z",
              "updatedAt": "2025-11-11T09:02:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NdLTV",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T09:03:52Z",
          "updatedAt": "2025-11-11T09:03:52Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Responder has access to new key schedule. So technically it could accept messages using trial decryption with new keys before receiving confirmation from the initiator. This text instructs implementers not to do that.",
              "createdAt": "2025-11-11T09:03:52Z",
              "updatedAt": "2025-11-11T09:03:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NdLdr",
          "commit": {
            "abbreviatedOid": "a11a6a5"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T09:04:01Z",
          "updatedAt": "2025-11-11T09:04:02Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Updated",
              "createdAt": "2025-11-11T09:04:01Z",
              "updatedAt": "2025-11-11T09:04:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NwFMG",
          "commit": {
            "abbreviatedOid": "9152aeb"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T07:06:16Z",
          "updatedAt": "2025-11-12T07:06:16Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "```suggestion\r\nUpon receiving the responder's ACK matching the updated epoch, the initiator completes the transition by synchronizing transmit and receive epochs (tx := rx), disabling retention, and clearing the update flag. The state machine returns to FINISHED, ready for subsequent updates.\r\n```",
              "createdAt": "2025-11-12T07:06:16Z",
              "updatedAt": "2025-11-12T07:06:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NwGHv",
          "commit": {
            "abbreviatedOid": "9152aeb"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good except for a Nit. ",
          "createdAt": "2025-11-12T07:07:53Z",
          "updatedAt": "2025-11-12T07:07:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMJPqLM7YEngy",
          "commit": {
            "abbreviatedOid": "9152aeb"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-04T16:51:28Z",
          "updatedAt": "2026-01-04T16:51:28Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "I think Tiru is correct with the suggested change.",
              "createdAt": "2026-01-04T16:51:28Z",
              "updatedAt": "2026-01-04T16:51:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOMJPqLM6ysH36",
      "title": "Update to RFC9261",
      "url": "https://github.com/tlswg/tls-key-update/pull/89",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-11-11T07:10:49Z",
      "updatedAt": "2026-01-06T13:32:03Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "09dc70a5edfd652cfa77e7edef6ba63085b0590b",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-11",
      "headRefOid": "bab4ab43e70d8535ba886c31303fcb981e384c6c",
      "closedAt": "2026-01-06T13:31:59Z",
      "mergedAt": "2026-01-06T13:31:59Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "69208b6f21d6f90681c3c27083dd3281c8241f4e"
      },
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "Update to address comments from @ilaril, see https://github.com/tlswg/tls-key-update/issues/88",
          "createdAt": "2025-11-11T07:12:07Z",
          "updatedAt": "2025-11-11T07:12:07Z"
        },
        {
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we need to make RFC 9261 a normative reference and we also need to update it.",
          "createdAt": "2025-11-12T14:48:58Z",
          "updatedAt": "2025-11-12T14:48:58Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "Looks technically good on quick look \u2014 editorial stuff can come later.",
          "createdAt": "2025-11-25T07:15:16Z",
          "updatedAt": "2025-11-25T07:15:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7Nc-Z9",
          "commit": {
            "abbreviatedOid": "99b21f1"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T08:53:04Z",
          "updatedAt": "2025-11-11T08:53:05Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This is not necessary and causes issues with the finished transcript hash calculation \u2014 since CertificateVerify hash is assumed to be prefix of Finished hash.\r\n\r\nThe reason it is not needed is that `exporter_secret_<n>` already incorporates the latest EKU exchange, and thus the authenticator transcript inherits that via Handshake Context, which comes from epoch-aware exporter.",
              "createdAt": "2025-11-11T08:53:04Z",
              "updatedAt": "2025-11-11T08:53:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NdD4x",
          "commit": {
            "abbreviatedOid": "99b21f1"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T08:57:43Z",
          "updatedAt": "2025-11-11T08:57:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This is not backward-compatible as it does not work with EKU-unaware applications. Applications that do not support EKU must continue to work even if EKU is enabled at TLS level \u2014 just not get all the benefits.\r\n\r\nAnd such Exported Authenticators must be sent together with the correct epoch value, so it is possible to verify the authenticators.",
              "createdAt": "2025-11-11T08:57:43Z",
              "updatedAt": "2025-11-11T08:57:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Nhy4v",
          "commit": {
            "abbreviatedOid": "99b21f1"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T13:56:00Z",
          "updatedAt": "2025-11-11T13:56:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Good point, updated text. ",
              "createdAt": "2025-11-11T13:56:00Z",
              "updatedAt": "2025-11-11T13:56:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NiGVR",
          "commit": {
            "abbreviatedOid": "99b21f1"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T14:12:20Z",
          "updatedAt": "2025-11-11T14:12:20Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Fixed, please check. ",
              "createdAt": "2025-11-11T14:12:20Z",
              "updatedAt": "2025-11-11T14:12:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NrPZ_",
          "commit": {
            "abbreviatedOid": "72843ef"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-11T23:57:09Z",
          "updatedAt": "2025-11-11T23:57:09Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I am not sure if that's correct. We use main secret from the previous key schedule, hence:\r\n\r\n- attacker won't be able to obtain new traffic secrets even if it somehow managed to modify key shares in flight\r\n- peers will get AEAD failure and terminate the connection\r\n\r\nAm I missing something?",
              "createdAt": "2025-11-11T23:57:09Z",
              "updatedAt": "2025-11-11T23:57:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NrRSt",
          "commit": {
            "abbreviatedOid": "72843ef"
          },
          "author": "yaroslavros",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T00:00:20Z",
          "updatedAt": "2025-11-12T00:00:20Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Or are you referring to an attacker who:\r\n- has obtained previous main key / key schedule\r\n- is able to mitm bi-directional communication between peers\r\n\r\nIf that's the case I think threat model need to be clarified.",
              "createdAt": "2025-11-12T00:00:20Z",
              "updatedAt": "2025-11-12T00:00:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7NuQsm",
          "commit": {
            "abbreviatedOid": "72843ef"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T05:05:48Z",
          "updatedAt": "2025-11-12T05:05:48Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> Or are you referring to an attacker who:\r\n> \r\n>     * has obtained previous main key / key schedule\r\n> \r\n>     * is able to mitm bi-directional communication between peers\r\n> \r\n> \r\n> If that's the case I think threat model need to be clarified.\r\n\r\nYes, I am referring to his attack. Updated the first paragraph in the section to explain threat model, please check. ",
              "createdAt": "2025-11-12T05:05:48Z",
              "updatedAt": "2025-11-12T05:05:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3OZW",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:40:39Z",
          "updatedAt": "2025-11-12T14:40:40Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nExported Authenticators {{!RFC9261}} immediately after completing an EKU.\r\n```",
              "createdAt": "2025-11-12T14:40:39Z",
              "updatedAt": "2025-11-12T14:40:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3Rb0",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:43:24Z",
          "updatedAt": "2025-11-12T14:43:24Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nAs a result, validation procedures specified in Section 5.2.4 of {{!RFC9261}} will fail, thereby\r\n```",
              "createdAt": "2025-11-12T14:43:24Z",
              "updatedAt": "2025-11-12T14:43:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3SsM",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:44:36Z",
          "updatedAt": "2025-11-12T14:44:36Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Shouldn't we specify the API here -- in the same way as RFC 9261 defines APIs?",
              "createdAt": "2025-11-12T14:44:36Z",
              "updatedAt": "2025-11-12T14:44:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3TXb",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:45:15Z",
          "updatedAt": "2025-11-12T14:45:15Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "What does \"request or verify\" mean here? ",
              "createdAt": "2025-11-12T14:45:15Z",
              "updatedAt": "2025-11-12T14:45:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3TsH",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:45:31Z",
          "updatedAt": "2025-11-12T14:45:32Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n{{!RFC9261}} remain unchanged, so existing applications\r\n```",
              "createdAt": "2025-11-12T14:45:31Z",
              "updatedAt": "2025-11-12T14:45:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3U3I",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T14:46:36Z",
          "updatedAt": "2025-11-12T14:46:36Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Is it really required to leave these applications unchanged? There are not many applications today that use RFC 9261. Hence, I do not believe there is a lot of harm in modifying them --- if necessary.",
              "createdAt": "2025-11-12T14:46:36Z",
              "updatedAt": "2025-11-12T14:46:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N3806",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T15:18:07Z",
          "updatedAt": "2025-11-12T15:18:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Yes, because it would be a breaking change to the TLS library, and to both application endpoints. Even one released TLS library having stable support for RFC 9261, or one application actually using it would make it no-go.\r\n\r\nWhile it is easy for libraries to make breaking changes (it frequently happens accidentally), such changes have very high cost to everyone else. It can be from difficult to virtually impossible to update applications across such change, and as old versions go out of security support, that is a major source of forever-days.\r\n\r\nNote that similarly to RFC 9261 being implementable in application layer on top of classical TLS Exporter, this is implementable in application layer on top of Epoch-Aware TLS Exporter.",
              "createdAt": "2025-11-12T15:18:07Z",
              "updatedAt": "2025-11-12T15:30:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N4AqE",
          "commit": {
            "abbreviatedOid": "b01de27"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T15:21:20Z",
          "updatedAt": "2025-11-12T15:21:20Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "As note, TLS library API is not strictly necessary, as this can be implemented on top of Epoch-Aware TLS Exporter in the same way as RFC 9261 can be implemented on top of classical TLS Exporter. RFC 9261 just encourages using TLS library implementation, if available.",
              "createdAt": "2025-11-12T15:21:20Z",
              "updatedAt": "2025-11-12T15:21:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N4N8d",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T15:31:01Z",
          "updatedAt": "2025-11-12T15:31:01Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "The side that requests an authenticator (request API) .\r\nThe side that validates an authenticator received from its peer (validate API).\r\n\r\nBoth these APIs are defined in RFC 9261. ",
              "createdAt": "2025-11-12T15:31:01Z",
              "updatedAt": "2025-11-12T15:31:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7N4Qpw",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-12T15:33:12Z",
          "updatedAt": "2025-11-12T15:33:13Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Good point; other than CloudFlare deploying it, I don't see any TLS library that supports RFC9261. ",
              "createdAt": "2025-11-12T15:33:12Z",
              "updatedAt": "2025-11-12T15:33:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7O5LMJ",
          "commit": {
            "abbreviatedOid": "b01de27"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-17T05:53:59Z",
          "updatedAt": "2025-11-17T05:53:59Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Updated text to clarify that TLS library API is not mandatory. ",
              "createdAt": "2025-11-17T05:53:59Z",
              "updatedAt": "2025-11-17T05:53:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7O5QNp",
          "commit": {
            "abbreviatedOid": "5d80825"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-17T06:00:44Z",
          "updatedAt": "2025-11-17T06:00:44Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Updated text to clarify it is possible to implement at the application layer as an exception without any changes to TLS library. ",
              "createdAt": "2025-11-17T06:00:44Z",
              "updatedAt": "2025-11-17T06:00:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOMJPqLM6zMWDQ",
      "title": "Added Security Goals and fixed terminology",
      "url": "https://github.com/tlswg/tls-key-update/pull/91",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address https://github.com/tlswg/tls-key-update/issues/77",
      "createdAt": "2025-11-13T10:24:08Z",
      "updatedAt": "2026-01-06T13:34:01Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "69208b6f21d6f90681c3c27083dd3281c8241f4e",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-12",
      "headRefOid": "4cc3cab1958cbb8720f19955cd6a9b2a621992d3",
      "closedAt": "2026-01-06T13:33:56Z",
      "mergedAt": "2026-01-06T13:33:56Z",
      "mergedBy": "hannestschofenig",
      "mergeCommit": {
        "oid": "d2db856fa748537bed423cc6418b3aefb8f13a00"
      },
      "comments": [
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "I suppose the security goals are now something that can be achieved. Feature like this needs formal analysis, which can inform what the goals should be.",
          "createdAt": "2025-11-25T07:32:27Z",
          "updatedAt": "2025-11-25T07:32:27Z"
        },
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suppose the security goals are now something that can be achieved. Feature like this needs formal analysis, which can inform what the goals should be.\r\n\r\nYes, formal analysis is mandatory for the draft to progress.  ",
          "createdAt": "2025-11-25T14:02:10Z",
          "updatedAt": "2025-11-25T14:02:10Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suppose the security goals are now something that can be achieved. Feature like this needs formal analysis, which can inform what the goals should be.\r\n\r\nSure. I am working on formal analysis of this draft. For formal analysis, we need to first align on the desired security goals and the terminology. Hence, issues #76, #77, and #78 were created.",
          "createdAt": "2025-11-30T08:16:10Z",
          "updatedAt": "2025-11-30T08:16:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7OQ39d",
          "commit": {
            "abbreviatedOid": "baa88ca"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-13T16:04:25Z",
          "updatedAt": "2025-11-13T16:04:25Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "What excludes an attacker that has somehow obtained the current AEAD keys and the salt used for next EKU on active connection but without any further access? EKU can not fix such compromise (without using EA).\r\n\r\n",
              "createdAt": "2025-11-13T16:04:25Z",
              "updatedAt": "2025-11-13T16:04:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7ORBfX",
          "commit": {
            "abbreviatedOid": "baa88ca"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-13T16:12:38Z",
          "updatedAt": "2025-11-13T16:12:39Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "TLS 1.3 has also post-handshake authentication (very rarely used, due to causing problems with many applications). I think it would be possible to make it work with EKU so it also can detect interference. PHA and EKU are mutually ordered as both use handshake messages. As consequence, it is always  possible to determine the correct epoch.",
              "createdAt": "2025-11-13T16:12:39Z",
              "updatedAt": "2025-11-13T16:12:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Oe4_R",
          "commit": {
            "abbreviatedOid": "baa88ca"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-14T10:21:34Z",
          "updatedAt": "2025-11-14T10:21:34Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Good point, updated the PR and https://github.com/tlswg/tls-key-update/pull/89 as well to discuss both PHA and exported authenticators. ",
              "createdAt": "2025-11-14T10:21:34Z",
              "updatedAt": "2025-11-14T10:21:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7OfDu6",
          "commit": {
            "abbreviatedOid": "baa88ca"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-14T10:30:32Z",
          "updatedAt": "2025-11-14T10:30:33Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "This section discusses an attacker whose access to the endpoint ended before the EKU and who is\r\nnot able to act as an MiTM during the EKU procedure.",
              "createdAt": "2025-11-14T10:30:32Z",
              "updatedAt": "2025-11-14T10:30:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7O4-XI",
          "commit": {
            "abbreviatedOid": "baa88ca"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-17T05:26:54Z",
          "updatedAt": "2025-11-17T05:26:54Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Added text to explain the attacker scope.",
              "createdAt": "2025-11-17T05:26:54Z",
              "updatedAt": "2025-11-17T05:26:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOMJPqLM671sf1",
      "title": "PCS for the Initial Exporter Secret",
      "url": "https://github.com/tlswg/tls-key-update/pull/92",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address issue raised in https://github.com/tlswg/tls-key-update/issues/90, https://github.com/tlswg/tls-key-update/issues/56 and https://github.com/tlswg/tls-key-update/issues/46",
      "createdAt": "2026-01-07T05:38:16Z",
      "updatedAt": "2026-01-14T05:03:50Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "81592c444f955fe1494154f0893325d8fa441a08",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-11",
      "headRefOid": "eb274d34670bea936c0a91a265fb1aac3e91eec9",
      "closedAt": "2026-01-14T05:03:50Z",
      "mergedAt": "2026-01-14T05:03:50Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "b689787e77750caa07f8f617741facb681230777"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7Zcidc",
          "commit": {
            "abbreviatedOid": "84a1923"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-11T17:24:50Z",
          "updatedAt": "2026-01-11T17:24:51Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nEKU messages MUST be transmitted reliably, like other DTLS handshake messages. If necessary, EKU messages MAY be fragmented as described in {{Section 5.5 of DTLS}}.\r\n```",
              "createdAt": "2026-01-11T17:24:50Z",
              "updatedAt": "2026-01-11T17:24:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Zcjte",
          "commit": {
            "abbreviatedOid": "84a1923"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-11T17:28:03Z",
          "updatedAt": "2026-01-11T17:28:03Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nexporter secret is static for the lifetime of the connection and is not updated by the EKU.\r\n```",
              "createdAt": "2026-01-11T17:28:03Z",
              "updatedAt": "2026-01-11T17:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Zcj1k",
          "commit": {
            "abbreviatedOid": "84a1923"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-11T17:28:24Z",
          "updatedAt": "2026-01-11T17:28:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nwhenever new application traffic keys are established through the EKU. A core design\r\n```",
              "createdAt": "2026-01-11T17:28:24Z",
              "updatedAt": "2026-01-11T17:28:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7ZckEh",
          "commit": {
            "abbreviatedOid": "4d5fcf4"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-11T17:28:54Z",
          "updatedAt": "2026-01-11T17:28:54Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\ngoal of this interface is that compromise of the exporter secret material at a later\r\n```",
              "createdAt": "2026-01-11T17:28:54Z",
              "updatedAt": "2026-01-11T17:28:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Zns41",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-12T14:31:08Z",
          "updatedAt": "2026-01-12T14:31:08Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nThe TLS 1.3 Key Schedule, see {{Figure 5 of TLS}}, derives the exporter_secret from the main secret. This\r\n```",
              "createdAt": "2026-01-12T14:31:08Z",
              "updatedAt": "2026-01-12T14:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7ZnuZE",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-12T14:32:23Z",
          "updatedAt": "2026-01-12T14:32:23Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nexporter_secret is static for the lifetime of the connection and is not updated by a standard key update.\r\n```",
              "createdAt": "2026-01-12T14:32:23Z",
              "updatedAt": "2026-01-12T14:32:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Znxoo",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-12T14:34:57Z",
          "updatedAt": "2026-01-12T14:34:57Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nA core design goal of this specification is not met if the exporter_secret does not change.\r\nTherefore, this document defines an exporter interface that derives a fresh exporter secret\r\nwhenever new application traffic keys are updated through the EKU.\r\n```",
              "createdAt": "2026-01-12T14:34:57Z",
              "updatedAt": "2026-01-12T14:34:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7Zn2PR",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-12T14:38:30Z",
          "updatedAt": "2026-01-12T14:38:30Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nIf the initial exporter secret for this new interface were identical to exporter_secret and all subsequent exporter secrets were derived from it deterministically, then compromising exporter_secret at any point during the lifetime of the connection would enable an attacker to recompute all exporter outputs derived from it. This would break post-compromise security for exported keying material.\r\n```",
              "createdAt": "2026-01-12T14:38:30Z",
              "updatedAt": "2026-01-12T14:38:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7ZoDyC",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-12T14:49:27Z",
          "updatedAt": "2026-01-12T14:49:27Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nstatic `exporter_secret` for the lifetime of the connection for compatiblity with \"legacy\" applications.\r\n```",
              "createdAt": "2026-01-12T14:49:27Z",
              "updatedAt": "2026-01-12T14:49:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMJPqLM7ZyhGJ",
          "commit": {
            "abbreviatedOid": "3811ad2"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-13T05:31:07Z",
          "updatedAt": "2026-01-13T05:31:07Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "\"subsequent exporter secrets were derived from it deterministically\" is not correct, subsequent exporter secrets are not derived from the initial exporter secret. \r\n\r\nI fixed the text as follows:\r\n\r\nIf the initial exporter secret for this new interface were identical to exporter_secret, then compromising exporter_secret at any point during the lifetime of the connection would enable an attacker to recompute all exporter outputs derived from it. This would break post-compromise security for exported keying material.",
              "createdAt": "2026-01-13T05:31:07Z",
              "updatedAt": "2026-01-13T05:31:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOMJPqLM68tXua",
      "title": "Update to Appendix",
      "url": "https://github.com/tlswg/tls-key-update/pull/93",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2026-01-12T14:07:48Z",
      "updatedAt": "2026-01-13T05:38:02Z",
      "baseRepository": "tlswg/tls-key-update",
      "baseRefName": "main",
      "baseRefOid": "81592c444f955fe1494154f0893325d8fa441a08",
      "headRepository": "tlswg/tls-key-update",
      "headRefName": "tireddy2-patch-12",
      "headRefOid": "0da0a3cf2b1bb86cd3a795b0e33515f643516110",
      "closedAt": "2026-01-13T05:38:02Z",
      "mergedAt": "2026-01-13T05:38:02Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "94e66eda7a37842fab74ae80b64fedb5ffd27bdd"
      },
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR will address https://github.com/tlswg/tls-key-update/issues/78",
          "createdAt": "2026-01-12T14:10:24Z",
          "updatedAt": "2026-01-12T14:10:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOMJPqLM7ZoIeL",
          "commit": {
            "abbreviatedOid": "0da0a3c"
          },
          "author": "hannestschofenig",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the update and the clarifications in the PR",
          "createdAt": "2026-01-12T14:53:22Z",
          "updatedAt": "2026-01-12T14:53:22Z",
          "comments": []
        }
      ]
    }
  ]
}